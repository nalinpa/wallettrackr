{% extends "base.html" %}

{% block title %}Monitor - Crypto Alpha Analysis{% endblock %}

{% block head %}
<style>
    .crypto-card {
        background: linear-gradient(145deg, #2c3e50, #34495e);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 15px;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    }
    
    .status-indicator {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: #6c757d;
        margin-right: 10px;
        display: inline-block;
    }
    
    .status-indicator.active {
        background: #28a745;
        animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
        0% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.7); }
        70% { box-shadow: 0 0 0 10px rgba(40, 167, 69, 0); }
        100% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0); }
    }
    
    .console-output {
        background: #0a0a0a;
        border: 1px solid #333;
        border-radius: 8px;
        padding: 20px;
        font-family: 'Courier New', monospace;
        font-size: 0.9rem;
        max-height: 600px;
        overflow-y: auto;
        white-space: pre-wrap;
        word-wrap: break-word;
        position: relative;
    }
    
    .console-line {
        margin-bottom: 5px;
        padding: 2px 0;
        line-height: 1.4;
        border-radius: 3px;
        padding-left: 5px;
    }
    
    .console-line.success { 
        color: #28a745; 
        background: rgba(40, 167, 69, 0.1);
    }
    .console-line.error { 
        color: #dc3545; 
        background: rgba(220, 53, 69, 0.1);
    }
    .console-line.info { 
        color: #17a2b8; 
    }
    .console-line.warning { 
        color: #ffc107; 
        background: rgba(255, 193, 7, 0.1);
    }
    .console-line.highlight {
        color: #ff6b6b;
        background: rgba(255, 107, 107, 0.1);
        font-weight: bold;
    }
    .console-line.progress {
        color: #6c5ce7;
    }
    .console-line.banner {
        color: #fd79a8;
        font-weight: bold;
        text-align: center;
        background: rgba(253, 121, 168, 0.1);
        margin: 10px 0;
        padding: 10px;
    }
    
    .console-controls {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 10;
    }
    
    .console-controls button {
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid #555;
        color: #fff;
        padding: 5px 10px;
        margin-left: 5px;
        border-radius: 4px;
        font-size: 0.8rem;
    }
    
    .console-controls button:hover {
        background: rgba(255, 255, 255, 0.1);
    }
    
    .alert-item {
        background: rgba(0, 0, 0, 0.3);
        padding: 15px;
        margin: 10px 0;
        border-radius: 8px;
        border-left: 4px solid #28a745;
        transition: all 0.3s ease;
        position: relative;
    }
    
    .alert-item:hover {
        background: rgba(0, 0, 0, 0.5);
        transform: translateY(-2px);
    }
    
    .alert-item.high-confidence {
        border-left-color: #dc3545;
        background: rgba(220, 53, 69, 0.1);
    }
    
    .alert-item.medium-confidence {
        border-left-color: #ffc107;
        background: rgba(255, 193, 7, 0.1);
    }
    
    .alert-item.sell-pressure {
        border-left-color: #6f42c1;
        background: rgba(111, 66, 193, 0.1);
    }
    
    .alert-token {
        font-size: 1.2rem;
        font-weight: bold;
        color: #ffc107;
        margin-bottom: 8px;
    }
    
    .alert-contract {
        font-family: 'Courier New', monospace;
        font-size: 0.85rem;
        background: rgba(0, 0, 0, 0.5);
        padding: 8px;
        border-radius: 4px;
        margin-top: 10px;
        word-break: break-all;
    }
    
    .stats-card {
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 15px;
        text-align: center;
        transition: all 0.3s ease;
    }
    
    .stats-card:hover {
        background: rgba(0, 0, 0, 0.5);
        transform: translateY(-2px);
    }
    
    .stats-number {
        font-size: 2rem;
        font-weight: bold;
        color: #28a745;
    }
    
    .auto-scroll {
        animation: scroll-indicator 1s ease-in-out infinite alternate;
    }
    
    @keyframes scroll-indicator {
        from { opacity: 0.5; }
        to { opacity: 1; }
    }

    .error-message {
        background: rgba(220, 53, 69, 0.2);
        border: 1px solid #dc3545;
        border-radius: 8px;
        padding: 15px;
        margin: 10px 0;
        color: #fff;
    }

    .loading-message {
        background: rgba(23, 162, 184, 0.2);
        border: 1px solid #17a2b8;
        border-radius: 8px;
        padding: 15px;
        margin: 10px 0;
        color: #fff;
        text-align: center;
    }

    .retry-button {
        background: #dc3545;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        margin-top: 10px;
        cursor: pointer;
    }

    .retry-button:hover {
        background: #c82333;
    }

    .toast-container {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 9999;
    }

    /* NEW: Enhanced alert animations */
    .alert-new {
        animation: alertHighlight 4s ease-in-out;
        border-left: 4px solid #28a745 !important;
        box-shadow: 0 0 20px rgba(40, 167, 69, 0.3);
    }

    @keyframes alertHighlight {
        0% { 
            background-color: rgba(40, 167, 69, 0.4);
            transform: scale(1.02);
        }
        25% { 
            background-color: rgba(40, 167, 69, 0.3);
        }
        50% { 
            background-color: rgba(40, 167, 69, 0.2);
        }
        100% { 
            background-color: transparent;
            transform: scale(1);
        }
    }

    /* NEW: Real-time update indicator */
    .real-time-indicator {
        position: absolute;
        top: 10px;
        right: 10px;
        background: #28a745;
        color: white;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 0.7rem;
        animation: realTimePulse 2s infinite;
    }

    @keyframes realTimePulse {
        0%, 100% { opacity: 0.7; transform: scale(1); }
        50% { opacity: 1; transform: scale(1.1); }
    }

    /* NEW: Alert counter badge */
    .alert-counter {
        position: absolute;
        top: -8px;
        right: -8px;
        background: #dc3545;
        color: white;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.7rem;
        font-weight: bold;
        animation: counterBounce 0.5s ease-out;
    }

    @keyframes counterBounce {
        0% { transform: scale(0); }
        50% { transform: scale(1.2); }
        100% { transform: scale(1); }
    }

    /* NEW: Connection status indicators */
    .connection-status {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 8px 12px;
        border-radius: 20px;
        font-size: 0.8rem;
        z-index: 1000;
        transition: all 0.3s ease;
    }

    .connection-status.online {
        border-left: 4px solid #28a745;
    }

    .connection-status.offline {
        border-left: 4px solid #dc3545;
        animation: connectionAlert 1s ease-in-out infinite alternate;
    }

    @keyframes connectionAlert {
        from { opacity: 0.7; }
        to { opacity: 1; }
    }

    /* NEW: Enhanced contract address styling */
    .contract-address-section {
        background: linear-gradient(135deg, rgba(0, 123, 255, 0.1), rgba(0, 123, 255, 0.05));
        border: 1px solid rgba(0, 123, 255, 0.2);
        border-radius: 8px;
        padding: 12px;
        margin-top: 10px;
        transition: all 0.3s ease;
    }

    .contract-address-section:hover {
        border-color: rgba(255, 193, 7, 0.5);
        background: linear-gradient(135deg, rgba(255, 193, 7, 0.1), rgba(255, 193, 7, 0.05));
    }

    .contract-address-display code {
        background: rgba(0, 0, 0, 0.6) !important;
        color: #e83e8c;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 0.85rem;
        padding: 8px 12px;
        border-radius: 6px;
        word-break: break-all;
        cursor: pointer;
        transition: all 0.3s ease;
        border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .contract-address-display code:hover {
        background: rgba(0, 123, 255, 0.2) !important;
        border-color: rgba(0, 123, 255, 0.5);
        transform: scale(1.02);
        box-shadow: 0 2px 8px rgba(0, 123, 255, 0.3);
    }

    /* NEW: Quick action buttons */
    .quick-actions {
        position: absolute;
        top: 10px;
        right: 10px;
        display: flex;
        gap: 4px;
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    .alert-item:hover .quick-actions {
        opacity: 1;
    }

    .quick-action-btn {
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.7rem;
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .quick-action-btn:hover {
        background: rgba(0, 123, 255, 0.8);
        border-color: rgba(0, 123, 255, 1);
    }
</style>
{% endblock %}

{% block content %}
<!-- Real-time update indicator -->
<div id="real-time-indicator" class="real-time-indicator" style="display: none;">
    <i class="fas fa-circle me-1"></i>LIVE
</div>

<!-- Connection status indicator -->
<div id="connection-status-indicator" class="connection-status online">
    <i class="fas fa-wifi me-1"></i>Connected
</div>

<div class="row mb-4">
    <div class="col-12">
        <div class="crypto-card p-4">
            <div class="d-flex justify-content-between align-items-center mb-3">
                <h3 class="mb-0">Monitor Control</h3>
                <div class="d-flex align-items-center">
                    <span id="alert-counter" class="alert-counter" style="display: none;">0</span>
                    <button class="btn btn-outline-light btn-sm" onclick="refreshAllData()" title="Refresh all data">
                        <i class="fas fa-sync-alt" id="refresh-icon"></i>
                    </button>
                </div>
            </div>
            
            <div class="d-flex align-items-center mb-3">
                <span class="status-indicator" id="status-indicator"></span>
                <span id="status-text" class="me-3">Loading...</span>
                <span id="monitor-status" class="badge bg-secondary">Inactive</span>
            </div>

            <div class="d-flex flex-wrap gap-2 mb-3">
                <button class="btn btn-success" id="start-btn" onclick="startMonitor()">
                    <i class="fas fa-play me-2"></i>Start Monitor
                </button>
                <button class="btn btn-danger" id="stop-btn" onclick="stopMonitor()" style="display: none;">
                    <i class="fas fa-stop me-2"></i>Stop Monitor
                </button>
                <button class="btn btn-warning" onclick="checkNow()">
                    <i class="fas fa-search me-2"></i>Check Now
                </button>
                <button class="btn btn-info" onclick="testConnection()">
                    <i class="fas fa-vial me-2"></i>Test Connection
                </button>
                <button class="btn btn-secondary" onclick="clearConsole()">
                    <i class="fas fa-trash me-2"></i>Clear Console
                </button>
                <button class="btn btn-outline-light btn-sm" onclick="toggleAutoScroll()">
                    <i class="fas fa-arrows-alt-v me-1"></i><span id="scroll-toggle-text">Auto Scroll: ON</span>
                </button>
            </div>

            <div class="row g-3">
                <div class="col-md-3">
                    <div class="stats-card">
                        <h6 class="text-muted text-uppercase mb-1">Last Check</h6>
                        <div class="h6 text-info" id="last-check">Never</div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="stats-card">
                        <h6 class="text-muted text-uppercase mb-1">Next Check</h6>
                        <div class="h6 text-warning" id="next-check">-</div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="stats-card">
                        <h6 class="text-muted text-uppercase mb-1">Total Alerts</h6>
                        <div class="stats-number" id="total-alerts">0</div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="stats-card">
                        <h6 class="text-muted text-uppercase mb-1">Known Tokens</h6>
                        <div class="stats-number" id="known-tokens">0</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Enhanced Console Output -->
<div class="row mb-4">
    <div class="col-12">
        <div class="crypto-card p-4">
            <h3 class="mb-3">
                Real-Time Console Output
                <span class="badge bg-success ms-2" id="console-status" style="display: none;">LIVE</span>
            </h3>
            <div class="console-output" id="console-output">
                <div class="console-line info">üöÄ Monitor console ready. Click "Check Now" or "Start Monitor" to begin.</div>
                <div class="console-line info">üí° Tip: Console will show detailed progress when analysis runs</div>
                <div class="console-line info">üîî New alerts will appear automatically when detected</div>
            </div>
            <div class="console-controls">
                <button onclick="exportConsoleLog()">
                    <i class="fas fa-download"></i> Export
                </button>
                <button onclick="pauseConsole()">
                    <i class="fas fa-pause" id="pause-icon"></i> <span id="pause-text">Pause</span>
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Configuration -->
<div class="row mb-4">
    <div class="col-12">
        <div class="crypto-card p-4">
            <h3 class="mb-3">Configuration</h3>
            
            <div class="row g-3">
                <div class="col-md-6 col-lg-4">
                    <label class="form-label">Check Interval (minutes)</label>
                    <select id="interval-select" class="form-select">
                        <option value="5">5 minutes</option>
                        <option value="15">15 minutes</option>
                        <option value="30">30 minutes</option>
                        <option value="60" selected>1 hour</option>
                        <option value="120">2 hours</option>
                        <option value="240">4 hours</option>
                    </select>
                </div>
                
                <div class="col-md-6 col-lg-4">
                    <label class="form-label">Networks</label>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="network-eth">
                        <label class="form-check-label" for="network-eth">Ethereum</label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="network-base" checked>
                        <label class="form-check-label" for="network-base">Base</label>
                    </div>
                </div>
                
                <div class="col-md-6 col-lg-4">
                    <label class="form-label">Wallets to Check</label>
                    <input type="number" id="num-wallets" value="50" min="5" max="174" class="form-control">
                </div>
                
                <div class="col-md-6 col-lg-4">
                    <label class="form-label">Min Wallets for Alert</label>
                    <input type="number" id="min-wallets" value="2" min="1" max="20" class="form-control">
                </div>
                
                <div class="col-md-6 col-lg-4">
                    <label class="form-label">Min ETH Spent</label>
                    <input type="number" id="min-eth" value="0.5" step="0.1" min="0.1" class="form-control">
                </div>
                
                <div class="col-md-6 col-lg-4">
                    <label class="form-label">Min Alpha Score</label>
                    <input type="number" id="min-score" value="30" min="10" max="100" class="form-control">
                </div>
            </div>
            
            <div class="form-check mt-3">
                <input class="form-check-input" type="checkbox" id="use-interval-timeframe" checked>
                <label class="form-check-label" for="use-interval-timeframe">
                    Only check new activity since last check (recommended)
                </label>
            </div>
        </div>
    </div>
</div>

<!-- Enhanced Recent Alerts -->
<div class="row">
    <div class="col-12">
        <div class="crypto-card p-4">
            <div class="d-flex justify-content-between align-items-center mb-3">
                <h3 class="mb-0">Recent Alerts</h3>
                <div class="d-flex align-items-center gap-2">
                    <span id="alerts-last-updated" class="text-muted small">Never updated</span>
                    <button class="btn btn-outline-light btn-sm" onclick="forceRefreshAlerts()" title="Force refresh alerts">
                        <i class="fas fa-sync" id="alerts-refresh-icon"></i>
                    </button>
                </div>
            </div>
            
            <div id="alerts-container">
                <div class="loading-message">
                    <div class="spinner-border spinner-border-sm text-primary me-2" role="status"></div>
                    <span>Loading alerts...</span>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Toast Container -->
<div id="toast-container" class="toast-container"></div>

<!-- New Alert Sound (hidden audio element) -->
<audio id="alert-sound" preload="auto" style="display: none;">
    <source src="data:audio/wav;base64,UklGRn4CAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YWoCAAC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4" type="audio/wav">
</audio>
{% endblock %}

{% block scripts %}
<script>
// Enhanced JavaScript for real-time alert monitoring
let isMonitorRunning = false;
let autoScroll = true;
let consolePaused = false;
let consoleBuffer = [];
let apiCallsInProgress = new Set();
let alertRefreshInterval;
let lastAlertCount = 0;
let currentAlerts = [];
let isRefreshing = false;
let alertsLoaded = false;
let lastAlertUpdate = null;
let soundEnabled = true;

// NEW: Enhanced real-time monitoring with better detection
let realTimeMonitorInterval;
let connectionCheckInterval;
let alertCheckFrequency = 2000; // Check every 2 seconds when active

// Initialize real-time monitoring
function initializeRealTimeMonitoring() {
    log('üîÑ Initializing real-time alert monitoring...', 'info');
    
    // Start connection monitoring
    startConnectionMonitoring();
    
    // Start alert monitoring
    startRealTimeAlertMonitoring();
    
    // Show real-time indicator
    const indicator = document.getElementById('real-time-indicator');
    if (indicator) {
        indicator.style.display = 'block';
    }
    
    log('‚úÖ Real-time monitoring active', 'success');
}

// NEW: Enhanced alert monitoring with better change detection
function startRealTimeAlertMonitoring() {
    if (realTimeMonitorInterval) {
        clearInterval(realTimeMonitorInterval);
    }
    
    realTimeMonitorInterval = setInterval(async () => {
        if (!isRefreshing && !document.hidden) {
            try {
                await checkForNewAlerts();
            } catch (error) {
                console.debug('Alert check failed:', error.message);
            }
        }
    }, alertCheckFrequency);
    
    log(`üîî Alert monitoring started (checking every ${alertCheckFrequency/1000}s)`, 'info');
}

// NEW: Improved new alert detection
async function checkForNewAlerts() {
    try {
        // Get current stats
        const liveUpdates = await makeApiCall('/api/monitor/live-updates');
        const currentAlertCount = liveUpdates.stats?.total_alerts || 0;
        
        // Check if we have new alerts
        if (currentAlertCount > lastAlertCount) {
            const newAlertCount = currentAlertCount - lastAlertCount;
            log(`üîî ${newAlertCount} new alert(s) detected!`, 'success');
            
            // Update the alert counter badge
            updateAlertCounter(newAlertCount);
            
            // Refresh alerts display
            await loadAlerts(true); // Force refresh
            
            // Play sound notification
            playAlertSound();
            
            // Show toast notification
            showToast(`üö® ${newAlertCount} new alert(s) found!`, 'success');
            
            lastAlertCount = currentAlertCount;
        }
        
        // Update stats in real-time
        updateStatsDisplay(liveUpdates);
        
    } catch (error) {
        // Silent fail for real-time checks to avoid spam
        console.debug('Real-time check failed:', error.message);
    }
}

// NEW: Alert counter badge functionality
function updateAlertCounter(newAlerts) {
    const counter = document.getElementById('alert-counter');
    if (counter && newAlerts > 0) {
        counter.textContent = newAlerts;
        counter.style.display = 'flex';
        
        // Auto-hide after 10 seconds
        setTimeout(() => {
            counter.style.display = 'none';
        }, 10000);
    }
}

// NEW: Play alert sound
function playAlertSound() {
    if (soundEnabled) {
        try {
            const audio = document.getElementById('alert-sound');
            if (audio) {
                audio.currentTime = 0;
                audio.play().catch(e => {
                    console.debug('Could not play alert sound:', e);
                });
            }
        } catch (error) {
            console.debug('Alert sound failed:', error);
        }
    }
}

// NEW: Connection monitoring
function startConnectionMonitoring() {
    if (connectionCheckInterval) {
        clearInterval(connectionCheckInterval);
    }
    
    connectionCheckInterval = setInterval(async () => {
        try {
            const response = await fetch('/api/health', { 
                method: 'GET',
                cache: 'no-cache',
                signal: AbortSignal.timeout(5000)
            });
            
            updateConnectionStatus(response.ok);
        } catch (error) {
            updateConnectionStatus(false);
        }
    }, 10000); // Check every 10 seconds
}

// NEW: Update connection status indicator
function updateConnectionStatus(isConnected) {
    const indicator = document.getElementById('connection-status-indicator');
    if (indicator) {
        if (isConnected) {
            indicator.className = 'connection-status online';
            indicator.innerHTML = '<i class="fas fa-wifi me-1"></i>Connected';
        } else {
            indicator.className = 'connection-status offline';
            indicator.innerHTML = '<i class="fas fa-wifi-slash me-1"></i>Disconnected';
        }
    }
}

// NEW: Update stats display in real-time
function updateStatsDisplay(liveUpdates) {
    if (liveUpdates.stats) {
        const stats = liveUpdates.stats;
        
        const totalAlertsElement = document.getElementById('total-alerts');
        const knownTokensElement = document.getElementById('known-tokens');
        
        if (totalAlertsElement && stats.total_alerts !== undefined) {
            totalAlertsElement.textContent = stats.total_alerts;
        }
        if (knownTokensElement && stats.known_tokens !== undefined) {
            knownTokensElement.textContent = stats.known_tokens;
        }
    }
    
    // Update timing info
    if (liveUpdates.last_check) {
        const lastCheckElement = document.getElementById('last-check');
        if (lastCheckElement) {
            const lastCheck = new Date(liveUpdates.last_check);
            lastCheckElement.textContent = lastCheck.toLocaleTimeString();
        }
    }
    
    if (liveUpdates.next_check) {
        const nextCheckElement = document.getElementById('next-check');
        if (nextCheckElement) {
            const nextCheck = new Date(liveUpdates.next_check);
            nextCheckElement.textContent = nextCheck.toLocaleTimeString();
        }
    }
}

// Enhanced API call function with better error handling
async function makeApiCall(url, options = {}) {
    const requestId = Date.now() + Math.random();
    
    try {
        apiCallsInProgress.add(requestId);
        
        const response = await fetch(url, {
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
                ...options.headers
            },
            ...options
        });

        if (!response.ok) {
            let errorText = '';
            try {
                errorText = await response.text();
            } catch (e) {
                errorText = 'Could not read error response';
            }
            
            throw new Error(`HTTP ${response.status}: ${response.statusText}. Response: ${errorText.substring(0, 200)}`);
        }

        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
            const text = await response.text();
            
            if (text.includes('<!DOCTYPE') || text.includes('<html')) {
                throw new Error(`Server returned HTML error page instead of JSON. Check server logs.`);
            }
            
            throw new Error(`Expected JSON but got ${contentType}. Response: ${text.substring(0, 200)}...`);
        }

        const data = await response.json();
        return data;

    } catch (error) {
        if (error.message.includes('Failed to fetch')) {
            error.message = `Network error: Could not connect to server. Check if the server is running.`;
        }
        
        throw error;
    } finally {
        apiCallsInProgress.delete(requestId);
    }
}

// Enhanced logging with different types and formatting
function log(message, type = 'info', showTimestamp = true) {
    console.log(`[Monitor] ${message}`);
    
    if (consolePaused) {
        consoleBuffer.push({message, type, showTimestamp, timestamp: new Date()});
        return;
    }
    
    const output = document.getElementById('console-output');
    if (!output) return;
    
    const line = document.createElement('div');
    line.className = `console-line ${type}`;
    
    let formattedMessage = message;
    if (showTimestamp) {
        const timestamp = new Date().toLocaleTimeString();
        formattedMessage = `[${timestamp}] ${message}`;
    }
    
    // Handle special formatting for monitor output
    if (message.includes('='.repeat(60))) {
        line.className = 'console-line banner';
        formattedMessage = message;
    } else if (message.includes('üöÄ') || message.includes('üîç') || message.includes('üìä')) {
        line.className = 'console-line highlight';
    } else if (message.includes('Progress:') || message.includes('[')) {
        line.className = 'console-line progress';
    }
    
    line.textContent = formattedMessage;
    output.appendChild(line);
    
    // Auto-scroll if enabled
    if (autoScroll) {
        output.scrollTop = output.scrollHeight;
    }
    
    // Keep only last 1000 lines for performance
    const lines = output.children;
    if (lines.length > 1000) {
        for (let i = 0; i < 100; i++) {
            output.removeChild(lines[0]);
        }
    }
}

// Helper function to show toast notifications
function showToast(message, type = 'info') {
    const toastContainer = document.getElementById('toast-container');
    if (!toastContainer) {
        const container = document.createElement('div');
        container.id = 'toast-container';
        container.className = 'toast-container position-fixed top-0 end-0 p-3';
        container.style.zIndex = '9999';
        document.body.appendChild(container);
    }
    
    const toastId = 'toast-' + Date.now();
    const bgClass = type === 'success' ? 'bg-success' : type === 'error' ? 'bg-danger' : 'bg-primary';
    
    const toastHtml = `
        <div id="${toastId}" class="toast align-items-center text-white ${bgClass} border-0" role="alert" aria-live="assertive" aria-atomic="true">
            <div class="d-flex">
                <div class="toast-body">
                    ${message}
                </div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
            </div>
        </div>
    `;
    
    document.getElementById('toast-container').insertAdjacentHTML('beforeend', toastHtml);
    
    const toastElement = document.getElementById(toastId);
    if (window.bootstrap && window.bootstrap.Toast) {
        const toast = new bootstrap.Toast(toastElement, { delay: 4000 });
        toast.show();
        
        toastElement.addEventListener('hidden.bs.toast', () => {
            toastElement.remove();
        });
    } else {
        setTimeout(() => {
            toastElement.style.display = 'none';
            setTimeout(() => toastElement.remove(), 500);
        }, 4000);
    }
}

// NEW: Enhanced loadAlerts function with real-time features
async function loadAlerts(forceRefresh = false) {
    const container = document.getElementById('alerts-container');
    if (!container) {
        console.error('‚ùå Alerts container not found');
        return;
    }
    
    // Prevent concurrent refreshes
    if (isRefreshing && !forceRefresh) {
        console.debug('‚è≥ Alert refresh already in progress');
        return;
    }
    
    try {
        isRefreshing = true;
        
        // Show loading state only on first load
        if (!alertsLoaded || forceRefresh) {
            if (container.children.length === 0) {
                container.innerHTML = `
                    <div class="text-center py-3" id="alerts-loading">
                        <div class="spinner-border spinner-border-sm text-primary me-2" role="status"></div>
                        <span class="text-muted">Loading alerts...</span>
                    </div>
                `;
            }
        }
        
        log(forceRefresh ? 'üîÑ Force refreshing alerts...' : 'üìã Loading alerts...', 'info');
        
        // Add cache-busting parameter for force refresh
        const url = forceRefresh ? 
            `/api/monitor/alerts?limit=20&_t=${Date.now()}` : 
            '/api/monitor/alerts?limit=20';
        
        const alerts = await makeApiCall(url);
        
        alertsLoaded = true;
        lastAlertUpdate = new Date();
        
        // Update "last updated" timestamp
        const lastUpdatedElement = document.getElementById('alerts-last-updated');
        if (lastUpdatedElement) {
            lastUpdatedElement.textContent = `Updated: ${lastAlertUpdate.toLocaleTimeString()}`;
        }
        
        if (!alerts || alerts.length === 0) {
            container.innerHTML = `
                <div class="text-center py-4">
                    <i class="fas fa-bell-slash fa-2x text-muted mb-3"></i>
                    <h6 class="text-muted">No alerts yet</h6>
                    <p class="text-muted small mb-0">Start monitoring or run an immediate check to generate alerts.</p>
                </div>
            `;
            log('üìã No alerts found', 'info');
            hideAlertSummary();
        } else {
            log(`üìã Displaying ${alerts.length} alerts (${forceRefresh ? 'force refresh' : 'normal load'})`, 'success');
            
            // NEW: Detect new alerts by comparing with current alerts
            const newAlerts = detectNewAlerts(alerts);
            
            // Render alerts
            renderAlerts(alerts, newAlerts);
            
            // Update current alerts cache
            currentAlerts = [...alerts];
            
            // Show alert summary
            showAlertSummary(alerts);
        }
        
        log('‚úÖ Alerts loaded successfully', 'success');
        
    } catch (error) {
        console.error('‚ùå Error loading alerts:', error);
        alertsLoaded = false;
        
        const errorHtml = `
            <div class="error-message">
                <strong>‚ùå Failed to load alerts:</strong><br>
                ${error.message}<br>
                <button class="retry-button mt-2" onclick="forceRefreshAlerts()">
                    üîÑ Retry Loading Alerts
                </button>
            </div>
        `;
        
        container.innerHTML = errorHtml;
        log(`‚ùå Failed to load alerts: ${error.message}`, 'error');
    } finally {
        isRefreshing = false;
    }
}

// NEW: Detect new alerts by comparing timestamps and IDs
function detectNewAlerts(alerts) {
    if (!currentAlerts || currentAlerts.length === 0) {
        return []; // First load, don't mark as new
    }
    
    const currentIds = new Set(currentAlerts.map(alert => alert.id));
    const newAlerts = alerts.filter(alert => !currentIds.has(alert.id));
    
    return newAlerts;
}

// NEW: Enhanced alert rendering with animations
function renderAlerts(alerts, newAlerts = []) {
    const container = document.getElementById('alerts-container');
    if (!container) return;
    
    const newAlertIds = new Set(newAlerts.map(alert => alert.id));
    
    let html = '';
    alerts.forEach((alert, index) => {
        const alertClass = getAlertClass(alert);
        const alertEmoji = getAlertEmoji(alert);
        const confidenceBadge = getConfidenceBadge(alert);
        const networkBadge = alert.network ? `<span class="badge bg-info ms-2">${alert.network.toUpperCase()}</span>` : '';
        
        // Check if this is a new alert
        const isNewAlert = newAlertIds.has(alert.id) ? 'alert-new' : '';
        
        const score = alert.data?.alpha_score || alert.data?.sell_score || 0;
        const ethValue = getValidatedEthValue(alert);
        const ethDisplay = formatEthValue(ethValue);
        const transactionCount = getTransactionCount(alert);
        
        const contractAddress = alert.data?.contract_address || '';
        const tokenSymbol = alert.token || '';
        const network = alert.network || 'ethereum';
        
        const contractDisplay = contractAddress ? 
            `${contractAddress.slice(0, 6)}...${contractAddress.slice(-4)}` : 
            'N/A';
        
        const explorerUrl = getExplorerUrl(contractAddress, network);
        
        html += `
            <div class="alert-item ${alertClass} ${isNewAlert}" data-alert-id="${alert.id}">
                <!-- Quick actions overlay -->
                <div class="quick-actions">
                    ${contractAddress ? `
                        <button class="quick-action-btn" onclick="copyAlertContract('${contractAddress}')" title="Copy contract">
                            <i class="fas fa-copy"></i>
                        </button>
                        <button class="quick-action-btn" onclick="window.open('${explorerUrl}', '_blank')" title="View on explorer">
                            <i class="fas fa-external-link-alt"></i>
                        </button>
                        <button class="quick-action-btn" onclick="window.open('https://dexscreener.com/${network}/${contractAddress}', '_blank')" title="DexScreener">
                            <i class="fas fa-chart-line"></i>
                        </button>
                    ` : ''}
                </div>
                
                <div class="d-flex justify-content-between align-items-start mb-3">
                    <div class="alert-token">
                        ${alertEmoji} ${alert.token} ${networkBadge} ${confidenceBadge}
                    </div>
                </div>
                
                <div class="row g-2 mb-3">
                    <div class="col-md-3 col-6">
                        <small class="text-muted">ETH Value:</small>
                        <div class="fw-bold text-success">${ethDisplay}</div>
                    </div>
                    <div class="col-md-3 col-6">
                        <small class="text-muted">Wallets:</small>
                        <div class="fw-bold text-info">${alert.data?.wallet_count || 0}</div>
                    </div>
                    <div class="col-md-3 col-6">
                        <small class="text-muted">Score:</small>
                        <div class="fw-bold text-warning">${score.toFixed(1)}</div>
                    </div>
                    <div class="col-md-3 col-6">
                        <small class="text-muted">Activity:</small>
                        <div class="small">${transactionCount} txns</div>
                    </div>
                </div>
                
                ${contractAddress ? `
                    <div class="contract-address-section">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <small class="text-muted fw-bold">
                                <i class="fas fa-file-contract me-1"></i>Contract Address
                            </small>
                            <div class="btn-group btn-group-sm">
                                <button class="btn btn-outline-light btn-sm" onclick="copyAlertContract('${contractAddress}')" title="Copy">
                                    <i class="fas fa-copy"></i>
                                </button>
                                <a href="${explorerUrl}" target="_blank" class="btn btn-outline-info btn-sm" title="Explorer">
                                    <i class="fas fa-search"></i>
                                </a>
                                <a href="https://dexscreener.com/${network}/${contractAddress}" target="_blank" class="btn btn-outline-warning btn-sm" title="DexScreener">
                                    <i class="fas fa-chart-line"></i>
                                </a>
                            </div>
                        </div>
                        <div class="contract-address-display">
                            <code onclick="copyAlertContract('${contractAddress}')" title="Click to copy">${contractAddress}</code>
                        </div>
                    </div>
                ` : `
                    <div class="contract-address-section">
                        <small class="text-muted">
                            <i class="fas fa-exclamation-triangle me-1"></i>Contract address not available
                        </small>
                    </div>
                `}
                
                <div class="row g-2 mt-2">
                    <div class="col-md-6">
                        <small class="text-muted">Platforms:</small>
                        <div class="small">${(alert.data?.platforms || alert.data?.methods || []).slice(0, 3).join(', ') || 'Unknown'}</div>
                    </div>
                    <div class="col-md-6">
                        <small class="text-muted">Type:</small>
                        <div class="small text-capitalize">${alert.alert_type?.replace('_', ' ') || 'Unknown'}</div>
                    </div>
                </div>
                
                ${isNewAlert ? `
                    <div class="alert alert-success py-1 mt-2 mb-2">
                        <small><i class="fas fa-sparkles me-1"></i>NEW ALERT - Just detected!</small>
                    </div>
                ` : ''}
                
                <div class="d-flex justify-content-between align-items-center mt-2">
                    <small class="text-muted">
                        üïê ${new Date(alert.timestamp).toLocaleString()}
                    </small>
                    <small class="text-muted">
                        ID: ${alert.id?.slice(-8) || 'N/A'}
                    </small>
                </div>
            </div>
        `;
    });
    
    container.innerHTML = html;
    
    // If there were new alerts, log them
    if (newAlerts.length > 0) {
        log(`‚ú® ${newAlerts.length} new alert(s) highlighted`, 'success');
        newAlerts.forEach(alert => {
            log(`üÜï New: ${alert.token} (${alert.network}) - ${alert.alert_type}`, 'highlight');
        });
    }
}

// NEW: Show/hide alert summary
function showAlertSummary(alerts) {
    const summaryElement = document.getElementById('alert-summary');
    if (!summaryElement || !alerts || alerts.length === 0) {
        hideAlertSummary();
        return;
    }
    
    // Calculate summary stats
    const newTokens = alerts.filter(a => a.alert_type === 'new_token').length;
    const sellPressure = alerts.filter(a => a.alert_type === 'sell_pressure').length;
    const highConfidence = alerts.filter(a => a.confidence === 'HIGH').length;
    
    // Calculate recent alerts (last hour)
    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
    const recentAlerts = alerts.filter(a => new Date(a.timestamp) > oneHourAgo).length;
    
    // Update summary counts
    document.getElementById('new-tokens-count').textContent = newTokens;
    document.getElementById('sell-pressure-count').textContent = sellPressure;
    document.getElementById('high-confidence-count').textContent = highConfidence;
    document.getElementById('recent-alerts-count').textContent = recentAlerts;
    
    summaryElement.style.display = 'block';
}

function hideAlertSummary() {
    const summaryElement = document.getElementById('alert-summary');
    if (summaryElement) {
        summaryElement.style.display = 'none';
    }
}

// NEW: Force refresh alerts with visual feedback
async function forceRefreshAlerts() {
    const refreshIcon = document.getElementById('alerts-refresh-icon');
    if (refreshIcon) {
        refreshIcon.classList.add('fa-spin');
    }
    
    log('üîÑ Force refreshing alerts...', 'info');
    
    try {
        await loadAlerts(true);
        showToast('Alerts refreshed successfully!', 'success');
    } catch (error) {
        showToast('Failed to refresh alerts', 'error');
    } finally {
        if (refreshIcon) {
            refreshIcon.classList.remove('fa-spin');
        }
    }
}

// NEW: Refresh all data
async function refreshAllData() {
    const refreshIcon = document.getElementById('refresh-icon');
    if (refreshIcon) {
        refreshIcon.classList.add('fa-spin');
    }
    
    log('üîÑ Refreshing all data...', 'info');
    
    try {
        await Promise.all([
            loadStatus(),
            loadAlerts(true)
        ]);
        showToast('All data refreshed!', 'success');
    } catch (error) {
        showToast('Failed to refresh data', 'error');
    } finally {
        if (refreshIcon) {
            refreshIcon.classList.remove('fa-spin');
        }
    }
}

// Helper functions (existing functions with enhancements)
function getValidatedEthValue(alert) {
    if (!alert || !alert.data) return 0;
    
    let ethValue = 0;
    if (alert.alert_type === 'sell_pressure') {
        ethValue = alert.data.total_estimated_eth || alert.data.total_eth_value || alert.data.total_eth_spent || 0;
    } else {
        ethValue = alert.data.total_eth_spent || alert.data.total_eth_value || alert.data.total_estimated_eth || 0;
    }
    
    ethValue = parseFloat(ethValue) || 0;
    
    if (ethValue > 50 && alert.data?.wallet_count === 1) {
        const estimatedValue = Math.min(ethValue, 10);
        console.warn(`üîß Capping ETH value for ${alert.token} from ${ethValue} to ${estimatedValue}`);
        return estimatedValue;
    }
    
    return ethValue;
}

function formatEthValue(ethValue) {
    if (ethValue === 0) return '0.0000 ETH';
    if (ethValue < 0.0001) return '<0.0001 ETH';
    if (ethValue < 1) return `${ethValue.toFixed(4)} ETH`;
    if (ethValue < 10) return `${ethValue.toFixed(3)} ETH`;
    if (ethValue < 100) return `${ethValue.toFixed(2)} ETH`;
    return `${ethValue.toFixed(1)} ETH ‚ö†Ô∏è`;
}

function getTransactionCount(alert) {
    if (!alert || !alert.data) return 0;
    const transactionCount = alert.data.total_purchases || alert.data.total_sells || alert.data.total_transactions || alert.data.transaction_count || 0;
    return parseInt(transactionCount) || 0;
}

function getAlertClass(alert) {
    if (alert.confidence === 'HIGH') return 'high-confidence';
    if (alert.confidence === 'MEDIUM') return 'medium-confidence';
    if (alert.alert_type === 'sell_pressure') return 'sell-pressure';
    return '';
}

function getAlertEmoji(alert) {
    switch (alert.alert_type) {
        case 'new_token': return 'üÜï';
        case 'high_activity': return 'üìà';
        case 'sell_pressure': return 'üìâ';
        default: return 'üîî';
    }
}

function getConfidenceBadge(alert) {
    const confidence = alert.confidence || 'LOW';
    const colors = { 'HIGH': 'bg-danger', 'MEDIUM': 'bg-warning', 'LOW': 'bg-secondary' };
    const emojis = { 'HIGH': 'üî•', 'MEDIUM': '‚ö†Ô∏è', 'LOW': '‚ÑπÔ∏è' };
    return `<span class="badge ${colors[confidence]} ms-2">${emojis[confidence]} ${confidence}</span>`;
}

function getExplorerUrl(contractAddress, network) {
    if (!contractAddress) return '#';
    const explorers = {
        'ethereum': `https://etherscan.io/address/${contractAddress}`,
        'base': `https://basescan.org/address/${contractAddress}`,
        'arbitrum': `https://arbiscan.io/address/${contractAddress}`,
        'polygon': `https://polygonscan.com/address/${contractAddress}`
    };
    return explorers[network] || explorers['ethereum'];
}

function copyAlertContract(contractAddress) {
    if (!contractAddress || contractAddress === 'N/A') {
        showToast('No contract address available', 'error');
        return;
    }
    
    navigator.clipboard.writeText(contractAddress).then(() => {
        showToast(`Contract address copied! ${contractAddress.slice(0, 10)}...`, 'success');
        log(`üìã Copied contract address: ${contractAddress}`, 'info');
    }).catch(err => {
        console.error('Failed to copy contract address:', err);
        showToast('Failed to copy address', 'error');
    });
}

// Monitor control functions
async function loadStatus() {
    try {
        log('üì° Loading monitor status...', 'info');
        const data = await makeApiCall('/api/monitor/status');
        
        updateUI(data);
        log('‚úÖ Monitor status loaded successfully', 'success');
        
    } catch (error) {
        console.error('Failed to load status:', error);
        const statusText = document.getElementById('status-text');
        const monitorStatus = document.getElementById('monitor-status');
        
        if (statusText) statusText.textContent = 'Status unavailable';
        if (monitorStatus) {
            monitorStatus.textContent = 'Unknown';
            monitorStatus.className = 'badge bg-danger';
        }
    }
}

async function startMonitor() {
    log('üöÄ Starting crypto monitor...', 'info');
    
    try {
        const data = await makeApiCall('/api/monitor/start', { method: 'POST' });
        
        if (data.status === 'success') {
            log('‚úÖ Monitor started successfully!', 'success');
            showToast('Monitor started successfully!', 'success');
            
            // Increase alert check frequency when monitor is active
            alertCheckFrequency = 2000; // 2 seconds
            startRealTimeAlertMonitoring();
        } else {
            log(`‚ùå Failed to start monitor: ${data.message}`, 'error');
            showToast('Failed to start monitor', 'error');
        }
        loadStatus();
    } catch (error) {
        log(`‚ùå Error starting monitor: ${error.message}`, 'error');
        showToast('Error starting monitor', 'error');
    }
}

async function stopMonitor() {
    log('üõë Stopping crypto monitor...', 'info');
    
    try {
        const data = await makeApiCall('/api/monitor/stop', { method: 'POST' });
        
        if (data.status === 'success') {
            log('‚úÖ Monitor stopped successfully', 'success');
            showToast('Monitor stopped', 'success');
            
            // Reduce alert check frequency when monitor is inactive
            alertCheckFrequency = 10000; // 10 seconds
            startRealTimeAlertMonitoring();
        } else {
            log(`‚ùå Failed to stop monitor: ${data.message}`, 'error');
            showToast('Failed to stop monitor', 'error');
        }
        loadStatus();
    } catch (error) {
        log(`‚ùå Error stopping monitor: ${error.message}`, 'error');
        showToast('Error stopping monitor', 'error');
    }
}

async function checkNow() {
    log('üîç Starting immediate check...', 'warning');
    
    try {
        const data = await makeApiCall('/api/monitor/check-now', { method: 'POST' });
        
        if (data.status === 'success') {
            log('‚úÖ Immediate check initiated successfully!', 'success');
            showToast('Analysis started!', 'success');
            
            // Show progress updates
            setTimeout(() => log('üìä Analyzing wallet transactions...', 'progress'), 2000);
            setTimeout(() => log('üîç Checking for new token activity...', 'progress'), 5000);
            setTimeout(() => log('üìà Calculating scores...', 'progress'), 8000);
            setTimeout(() => {
                log('‚úÖ Analysis complete! Loading results...', 'success');
                loadAlerts(true);
                loadStatus();
            }, 12000);
        } else {
            log(`‚ùå Check failed: ${data.message}`, 'error');
            showToast('Check failed', 'error');
        }
    } catch (error) {
        log(`‚ùå Error running immediate check: ${error.message}`, 'error');
        showToast('Error running check', 'error');
    }
}

async function testConnection() {
    log('üîå Testing monitor connections...', 'info');
    
    try {
        const data = await makeApiCall('/api/monitor/test');
        
        if (data.status === 'success') {
            log('‚úÖ Connection test passed!', 'success');
            showToast('Connection test passed!', 'success');
            
            if (data.results) {
                Object.entries(data.results).forEach(([test, result]) => {
                    const status = result ? '‚úÖ' : '‚ùå';
                    log(`  ${status} ${test}: ${result ? 'OK' : 'FAILED'}`, result ? 'success' : 'error');
                });
            }
        } else {
            log(`‚ùå Connection test failed: ${data.message}`, 'error');
            showToast('Connection test failed', 'error');
        }
    } catch (error) {
        log(`‚ùå Connection test error: ${error.message}`, 'error');
        showToast('Connection test error', 'error');
    }
}

// Console functions
function clearConsole() {
    const output = document.getElementById('console-output');
    if (output) {
        output.innerHTML = '';
        log('üöÄ Monitor console ready. Click "Check Now" or "Start Monitor" to begin.');
        log('üí° Tip: Console will show detailed progress when analysis runs');
        log('üîî New alerts will appear automatically when detected');
    }
}

function toggleAutoScroll() {
    autoScroll = !autoScroll;
    const toggleText = document.getElementById('scroll-toggle-text');
    if (toggleText) {
        toggleText.textContent = `Auto Scroll: ${autoScroll ? 'ON' : 'OFF'}`;
    }
    
    const output = document.getElementById('console-output');
    if (output) {
        if (autoScroll) {
            output.classList.add('auto-scroll');
            output.scrollTop = output.scrollHeight;
        } else {
            output.classList.remove('auto-scroll');
        }
    }
}

function pauseConsole() {
    consolePaused = !consolePaused;
    const pauseIcon = document.getElementById('pause-icon');
    const pauseText = document.getElementById('pause-text');
    
    if (pauseIcon && pauseText) {
        if (consolePaused) {
            pauseIcon.className = 'fas fa-play';
            pauseText.textContent = 'Resume';
            log('‚è∏Ô∏è Console output paused', 'warning');
        } else {
            pauseIcon.className = 'fas fa-pause';
            pauseText.textContent = 'Pause';
            log('‚ñ∂Ô∏è Console output resumed', 'success');
            
            // Flush buffer
            while (consoleBuffer.length > 0) {
                const buffered = consoleBuffer.shift();
                log(buffered.message, buffered.type, buffered.showTimestamp);
            }
        }
    }
}

function exportConsoleLog() {
    const output = document.getElementById('console-output');
    if (!output) return;
    
    const lines = Array.from(output.children).map(line => line.textContent).join('\n');
    
    const blob = new Blob([lines], { type: 'text/plain' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `monitor-log-${new Date().toISOString().split('T')[0]}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    window.URL.revokeObjectURL(url);
    
    log('üìÅ Console log exported successfully', 'success');
}

// Enhanced updateUI function
function updateUI(response) {
    const status = response.data || response;
    console.log('üîÑ Status updated:', status);

    const indicator = document.getElementById('status-indicator');
    const statusText = document.getElementById('status-text');
    const startBtn = document.getElementById('start-btn');
    const stopBtn = document.getElementById('stop-btn');
    const monitorStatus = document.getElementById('monitor-status');
    const consoleStatus = document.getElementById('console-status');
    
    isMonitorRunning = status.is_running;
    
    if (isMonitorRunning) {
        if (indicator) indicator.classList.add('active');
        if (statusText) statusText.textContent = 'Monitor Active';
        if (monitorStatus) {
            monitorStatus.className = 'badge bg-success';
            monitorStatus.textContent = 'Active';
        }
        if (consoleStatus) consoleStatus.style.display = 'inline-block';
        if (startBtn) startBtn.style.display = 'none';
        if (stopBtn) stopBtn.style.display = 'inline-block';
        
        // Increase monitoring frequency when active
        alertCheckFrequency = 2000;
        log('‚úÖ Monitor is running - real-time alerts enabled', 'success');
    } else {
        if (indicator) indicator.classList.remove('active');
        if (statusText) statusText.textContent = 'Monitor Inactive';
        if (monitorStatus) {
            monitorStatus.className = 'badge bg-secondary';
            monitorStatus.textContent = 'Inactive';
        }
        if (consoleStatus) consoleStatus.style.display = 'none';
        if (startBtn) startBtn.style.display = 'inline-block';
        if (stopBtn) stopBtn.style.display = 'none';
        
        // Reduce monitoring frequency when inactive
        alertCheckFrequency = 10000;
        log('üõë Monitor stopped - reduced monitoring frequency', 'info');
    }
    
    if (status.last_check) {
        const lastCheck = new Date(status.last_check);
        const lastCheckElement = document.getElementById('last-check');
        if (lastCheckElement) {
            lastCheckElement.textContent = lastCheck.toLocaleTimeString();
        }
    }
    
    if (status.next_check && isMonitorRunning) {
        const nextCheck = new Date(status.next_check);
        const nextCheckElement = document.getElementById('next-check');
        if (nextCheckElement) {
            nextCheckElement.textContent = nextCheck.toLocaleTimeString();
        }
    } else {
        const nextCheckElement = document.getElementById('next-check');
        if (nextCheckElement) {
            nextCheckElement.textContent = '-';
        }
    }
    
    // Update stats if available
    if (status.stats) {
        const totalAlertsElement = document.getElementById('total-alerts');
        const knownTokensElement = document.getElementById('known-tokens');
        
        if (totalAlertsElement) {
            const newCount = status.stats.total_alerts || 0;
            totalAlertsElement.textContent = newCount;
            
            // Update lastAlertCount if this is higher
            if (newCount > lastAlertCount) {
                lastAlertCount = newCount;
            }
        }
        if (knownTokensElement) {
            knownTokensElement.textContent = status.stats.known_tokens || 0;
        }
    }
}

// Configuration management functions
async function updateConfig() {
    const networks = [];
    const networkEth = document.getElementById('network-eth');
    const networkBase = document.getElementById('network-base');
    
    if (networkEth && networkEth.checked) networks.push('ethereum');
    if (networkBase && networkBase.checked) networks.push('base');
    
    const intervalSelect = document.getElementById('interval-select');
    const numWallets = document.getElementById('num-wallets');
    const useIntervalTimeframe = document.getElementById('use-interval-timeframe');
    
    const config = {
        check_interval_minutes: parseInt(intervalSelect?.value || 60),
        networks: networks,
        num_wallets: parseInt(numWallets?.value || 50),
        use_interval_for_timeframe: useIntervalTimeframe?.checked !== false
    };
    
    if (networks.length === 0) {
        showToast('Please select at least one network', 'error');
        return;
    }
    
    if (config.num_wallets < 5 || config.num_wallets > 174) {
        showToast('Number of wallets must be between 5 and 174', 'error');
        return;
    }
    
    log(`‚öôÔ∏è Updating configuration...`, 'info');
    
    try {
        const data = await makeApiCall('/api/monitor/config', {
            method: 'POST',
            body: JSON.stringify(config)
        });
        
        if (data.status === 'success') {
            log('‚úÖ Configuration updated successfully', 'success');
            showToast('Configuration updated successfully', 'success');
        } else {
            log(`‚ùå Config update failed: ${data.message}`, 'error');
            showToast(`Config update failed: ${data.message}`, 'error');
        }
    } catch (error) {
        log(`‚ùå Error updating config: ${error.message}`, 'error');
        showToast('Error updating configuration', 'error');
    }
}

async function updateThresholds() {
    const minWallets = document.getElementById('min-wallets');
    const minEth = document.getElementById('min-eth');
    const minScore = document.getElementById('min-score');
    
    const thresholds = {
        min_wallets: parseInt(minWallets?.value || 2),
        min_eth_total: parseFloat(minEth?.value || 0.5),
        min_alpha_score: parseFloat(minScore?.value || 30),
        min_sell_score: 25.0,
        min_transactions: 3,
        filter_stablecoins: true
    };
    
    if (thresholds.min_wallets < 1 || thresholds.min_wallets > 20) {
        showToast('Min wallets must be between 1 and 20', 'error');
        return;
    }
    
    if (thresholds.min_eth_total < 0.01 || thresholds.min_eth_total > 100) {
        showToast('Min ETH must be between 0.01 and 100', 'error');
        return;
    }
    
    log(`üéØ Updating alert thresholds...`, 'info');
    
    try {
        const data = await makeApiCall('/api/monitor/thresholds', {
            method: 'POST',
            body: JSON.stringify(thresholds)
        });
        
        if (data.status === 'success') {
            log('‚úÖ Alert thresholds updated successfully', 'success');
            showToast('Alert thresholds updated successfully', 'success');
        } else {
            log(`‚ùå Threshold update failed: ${data.message}`, 'error');
            showToast(`Threshold update failed: ${data.message}`, 'error');
        }
    } catch (error) {
        log(`‚ùå Error updating thresholds: ${error.message}`, 'error');
        showToast('Error updating thresholds', 'error');
    }
}

// Event listeners setup
function setupEventListeners() {
    // Configuration event listeners
    const configElements = ['interval-select', 'network-eth', 'network-base', 'num-wallets', 'use-interval-timeframe'];
    const thresholdElements = ['min-wallets', 'min-eth', 'min-score'];
    
    configElements.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.addEventListener('change', debounce(updateConfig, 1000));
            
            if (element.type === 'number') {
                element.addEventListener('input', debounce(updateConfig, 2000));
            }
        }
    });
    
    thresholdElements.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.addEventListener('change', debounce(updateThresholds, 1000));
            
            if (element.type === 'number') {
                element.addEventListener('input', debounce(updateThresholds, 2000));
            }
        }
    });
    
    // Sound toggle (you can add a button for this)
    document.addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.shiftKey && e.key === 'S') {
            e.preventDefault();
            soundEnabled = !soundEnabled;
            showToast(`Alert sound ${soundEnabled ? 'enabled' : 'disabled'}`, 'info');
            log(`üîä Alert sound ${soundEnabled ? 'enabled' : 'disabled'}`, 'info');
        }
    });
}

// Utility functions
function debounce(func, delay) {
    let timeoutId;
    return function (...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
}

// Initialize the monitor page
function initializeMonitorPage() {
    log('üåê Page loaded, initializing enhanced monitor interface...', 'info');
    
    // Start loading data
    loadStatus().then(() => {
        loadAlerts();
        log('‚úÖ Monitor page initialized successfully', 'success');
        
        // Initialize real-time monitoring
        initializeRealTimeMonitoring();
        
        // Get initial alert count
        setTimeout(async () => {
            try {
                const updates = await makeApiCall('/api/monitor/live-updates');
                lastAlertCount = updates.stats?.total_alerts || 0;
                console.log(`üìä Initial alert count: ${lastAlertCount}`);
            } catch (error) {
                console.debug('Could not get initial alert count:', error);
            }
        }, 2000);
    }).catch(error => {
        log(`‚ùå Failed to initialize monitor page: ${error.message}`, 'error');
    });
}

// Page lifecycle management
document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ Enhanced monitor page with real-time alerts initialized');
    
    // Initialize the monitor page
    initializeMonitorPage();
    
    // Setup event listeners
    setupEventListeners();
    
    // Welcome message
    setTimeout(() => {
        const output = document.getElementById('console-output');
        if (output && output.children.length <= 3) {
            log('üí° Enhanced Features:', 'info');
            log('  ‚Ä¢ Real-time alert detection every 2 seconds when monitor is active', 'info');
            log('  ‚Ä¢ Sound notifications for new alerts (Ctrl+Shift+S to toggle)', 'info');
            log('  ‚Ä¢ Auto-refreshing stats and connection monitoring', 'info');
            log('  ‚Ä¢ Visual highlights for new alerts', 'info');
            log('  ‚Ä¢ Enhanced contract address copying and links', 'info');
        }
    }, 3000);
});

// Cleanup on page unload
window.addEventListener('beforeunload', function() {
    if (realTimeMonitorInterval) clearInterval(realTimeMonitorInterval);
    if (connectionCheckInterval) clearInterval(connectionCheckInterval);
    log('üîí Real-time monitoring stopped', 'info');
});

// Keyboard shortcuts
document.addEventListener('keydown', function(e) {
    // Ctrl/Cmd + Enter to run immediate check
    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
        e.preventDefault();
        checkNow();
        log('‚å®Ô∏è Keyboard shortcut: Immediate check triggered', 'info');
    }
    
    // Ctrl/Cmd + Shift + C to clear console
    if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'C') {
        e.preventDefault();
        clearConsole();
        log('‚å®Ô∏è Keyboard shortcut: Console cleared', 'info');
    }
    
    // Ctrl/Cmd + R to refresh alerts
    if ((e.ctrlKey || e.metaKey) && e.key === 'r' && !e.shiftKey) {
        e.preventDefault();
        forceRefreshAlerts();
        log('‚å®Ô∏è Keyboard shortcut: Alerts refreshed', 'info');
    }
});

// Page visibility API to adjust monitoring frequency
document.addEventListener('visibilitychange', function() {
    if (document.hidden) {
        log('üëÅÔ∏è Tab hidden, reducing update frequency', 'info');
        alertCheckFrequency = Math.max(alertCheckFrequency * 2, 10000); // Reduce frequency
    } else {
        log('üëÅÔ∏è Tab visible, resuming normal updates', 'info');
        alertCheckFrequency = isMonitorRunning ? 2000 : 10000; // Reset to normal
        loadStatus(); // Immediate update when tab becomes visible
        checkForNewAlerts(); // Check for alerts immediately
    }
    
    // Restart monitoring with new frequency
    if (realTimeMonitorInterval) {
        startRealTimeAlertMonitoring();
    }
});

// Debug function for troubleshooting
window.debugMonitorPage = function() {
    console.log('=== Enhanced Monitor Page Debug Info ===');
    console.log('API calls in progress:', apiCallsInProgress.size);
    console.log('Monitor running:', isMonitorRunning);
    console.log('Auto scroll:', autoScroll);
    console.log('Console paused:', consolePaused);
    console.log('Buffer size:', consoleBuffer.length);
    console.log('Alert check frequency:', alertCheckFrequency);
    console.log('Last alert count:', lastAlertCount);
    console.log('Current alerts:', currentAlerts.length);
    console.log('Sound enabled:', soundEnabled);
    console.log('Last alert update:', lastAlertUpdate);
    console.log('Real-time monitoring active:', !!realTimeMonitorInterval);
    console.log('Connection monitoring active:', !!connectionCheckInterval);
    
    // Test endpoints
    const endpoints = [
        '/api/monitor/status',
        '/api/monitor/alerts',
        '/api/monitor/live-updates',
        '/api/health'
    ];
    
    console.log('Testing monitor endpoints...');
    endpoints.forEach(async (endpoint) => {
        try {
            const response = await fetch(endpoint);
            console.log(`${endpoint}: ${response.status} ${response.statusText}`);
        } catch (error) {
            console.error(`${endpoint}: ERROR -`, error.message);
        }
    });
};

console.log('üí° Enhanced debug function available: debugMonitorPage()');
console.log('‚å®Ô∏è Keyboard shortcuts: Ctrl+Enter (check), Ctrl+Shift+C (clear), Ctrl+R (refresh)');
console.log('üîä Sound toggle: Ctrl+Shift+S');
</script>
{% endblock %}