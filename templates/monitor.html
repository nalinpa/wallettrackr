{% extends "base.html" %}

{% block title %}Monitor - Crypto Alpha Analysis{% endblock %}

{% block head %}
<style>
    .crypto-card {
        background: linear-gradient(145deg, #2c3e50, #34495e);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 15px;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    }
    
    .status-indicator {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: #6c757d;
        margin-right: 10px;
        display: inline-block;
    }
    
    .status-indicator.active {
        background: #28a745;
        animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
        0% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.7); }
        70% { box-shadow: 0 0 0 10px rgba(40, 167, 69, 0); }
        100% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0); }
    }
    
    .console-output {
        background: #0a0a0a;
        border: 1px solid #333;
        border-radius: 8px;
        padding: 20px;
        font-family: 'Courier New', monospace;
        font-size: 0.9rem;
        max-height: 600px;
        overflow-y: auto;
        white-space: pre-wrap;
        word-wrap: break-word;
        position: relative;
    }
    
    .console-line {
        margin-bottom: 5px;
        padding: 2px 0;
        line-height: 1.4;
        border-radius: 3px;
        padding-left: 5px;
    }
    
    .console-line.success { 
        color: #28a745; 
        background: rgba(40, 167, 69, 0.1);
    }
    .console-line.error { 
        color: #dc3545; 
        background: rgba(220, 53, 69, 0.1);
    }
    .console-line.info { 
        color: #17a2b8; 
    }
    .console-line.warning { 
        color: #ffc107; 
        background: rgba(255, 193, 7, 0.1);
    }
    .console-line.highlight {
        color: #ff6b6b;
        background: rgba(255, 107, 107, 0.1);
        font-weight: bold;
    }
    .console-line.progress {
        color: #6c5ce7;
    }
    .console-line.banner {
        color: #fd79a8;
        font-weight: bold;
        text-align: center;
        background: rgba(253, 121, 168, 0.1);
        margin: 10px 0;
        padding: 10px;
    }
    
    .console-controls {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 10;
    }
    
    .console-controls button {
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid #555;
        color: #fff;
        padding: 5px 10px;
        margin-left: 5px;
        border-radius: 4px;
        font-size: 0.8rem;
    }
    
    .console-controls button:hover {
        background: rgba(255, 255, 255, 0.1);
    }
    
    .alert-item {
        background: rgba(0, 0, 0, 0.3);
        padding: 15px;
        margin: 10px 0;
        border-radius: 8px;
        border-left: 4px solid #28a745;
        transition: all 0.3s ease;
    }
    
    .alert-item:hover {
        background: rgba(0, 0, 0, 0.5);
        transform: translateY(-2px);
    }
    
    .alert-item.high-confidence {
        border-left-color: #dc3545;
        background: rgba(220, 53, 69, 0.1);
    }
    
    .alert-item.medium-confidence {
        border-left-color: #ffc107;
        background: rgba(255, 193, 7, 0.1);
    }
    
    .alert-item.sell-pressure {
        border-left-color: #6f42c1;
        background: rgba(111, 66, 193, 0.1);
    }
    
    .alert-token {
        font-size: 1.2rem;
        font-weight: bold;
        color: #ffc107;
        margin-bottom: 8px;
    }
    
    .alert-contract {
        font-family: 'Courier New', monospace;
        font-size: 0.85rem;
        background: rgba(0, 0, 0, 0.5);
        padding: 8px;
        border-radius: 4px;
        margin-top: 10px;
        word-break: break-all;
    }
    
    .stats-card {
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 15px;
        text-align: center;
        transition: all 0.3s ease;
    }
    
    .stats-card:hover {
        background: rgba(0, 0, 0, 0.5);
        transform: translateY(-2px);
    }
    
    .stats-number {
        font-size: 2rem;
        font-weight: bold;
        color: #28a745;
    }
    
    .auto-scroll {
        animation: scroll-indicator 1s ease-in-out infinite alternate;
    }
    
    @keyframes scroll-indicator {
        from { opacity: 0.5; }
        to { opacity: 1; }
    }

    .error-message {
        background: rgba(220, 53, 69, 0.2);
        border: 1px solid #dc3545;
        border-radius: 8px;
        padding: 15px;
        margin: 10px 0;
        color: #fff;
    }

    .loading-message {
        background: rgba(23, 162, 184, 0.2);
        border: 1px solid #17a2b8;
        border-radius: 8px;
        padding: 15px;
        margin: 10px 0;
        color: #fff;
        text-align: center;
    }

    .retry-button {
        background: #dc3545;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        margin-top: 10px;
        cursor: pointer;
    }

    .retry-button:hover {
        background: #c82333;
    }

    .toast-container {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 9999;
    }

    .alert-new {
        animation: alertHighlight 3s ease-in-out;
        border-left: 4px solid #28a745 !important;
    }

    @keyframes alertHighlight {
        0% { background-color: rgba(40, 167, 69, 0.3); }
        100% { background-color: transparent; }
    }
</style>
{% endblock %}

{% block content %}
<div class="row mb-4">
    <div class="col-12">
        <div class="crypto-card p-4">
            <h3 class="mb-3">Monitor Control</h3>
            
            <div class="d-flex align-items-center mb-3">
                <span class="status-indicator" id="status-indicator"></span>
                <span id="status-text" class="me-3">Loading...</span>
                <span id="monitor-status" class="badge bg-secondary">Inactive</span>
            </div>

            <div class="d-flex flex-wrap gap-2 mb-3">
                <button class="btn btn-success" id="start-btn" onclick="startMonitor()">
                    <i class="fas fa-play me-2"></i>Start Monitor
                </button>
                <button class="btn btn-danger" id="stop-btn" onclick="stopMonitor()" style="display: none;">
                    <i class="fas fa-stop me-2"></i>Stop Monitor
                </button>
                <button class="btn btn-warning" onclick="checkNow()">
                    <i class="fas fa-search me-2"></i>Check Now
                </button>
                <button class="btn btn-info" onclick="testConnection()">
                    <i class="fas fa-vial me-2"></i>Test Connection
                </button>
                <button class="btn btn-secondary" onclick="clearConsole()">
                    <i class="fas fa-trash me-2"></i>Clear Console
                </button>
                <button class="btn btn-outline-light btn-sm" onclick="toggleAutoScroll()">
                    <i class="fas fa-arrows-alt-v me-1"></i><span id="scroll-toggle-text">Auto Scroll: ON</span>
                </button>
            </div>

            <div class="row g-3">
                <div class="col-md-3">
                    <div class="stats-card">
                        <h6 class="text-muted text-uppercase mb-1">Last Check</h6>
                        <div class="h6 text-info" id="last-check">Never</div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="stats-card">
                        <h6 class="text-muted text-uppercase mb-1">Next Check</h6>
                        <div class="h6 text-warning" id="next-check">-</div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="stats-card">
                        <h6 class="text-muted text-uppercase mb-1">Total Alerts</h6>
                        <div class="stats-number" id="total-alerts">0</div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="stats-card">
                        <h6 class="text-muted text-uppercase mb-1">Known Tokens</h6>
                        <div class="stats-number" id="known-tokens">0</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Enhanced Console Output -->
<div class="row mb-4">
    <div class="col-12">
        <div class="crypto-card p-4">
            <h3 class="mb-3">
                Real-Time Console Output
                <span class="badge bg-success ms-2" id="console-status" style="display: none;">LIVE</span>
            </h3>
            <div class="console-output" id="console-output">
                <div class="console-line info">üöÄ Monitor console ready. Click "Check Now" or "Start Monitor" to begin.</div>
                <div class="console-line info">üí° Tip: Console will show detailed progress when analysis runs</div>
            </div>
            <div class="console-controls">
                <button onclick="exportConsoleLog()">
                    <i class="fas fa-download"></i> Export
                </button>
                <button onclick="pauseConsole()">
                    <i class="fas fa-pause" id="pause-icon"></i> <span id="pause-text">Pause</span>
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Configuration -->
<div class="row mb-4">
    <div class="col-12">
        <div class="crypto-card p-4">
            <h3 class="mb-3">Configuration</h3>
            
            <div class="row g-3">
                <div class="col-md-6 col-lg-4">
                    <label class="form-label">Check Interval (minutes)</label>
                    <select id="interval-select" class="form-select">
                        <option value="5">5 minutes</option>
                        <option value="15">15 minutes</option>
                        <option value="30">30 minutes</option>
                        <option value="60" selected>1 hour</option>
                        <option value="120">2 hours</option>
                        <option value="240">4 hours</option>
                    </select>
                </div>
                
                <div class="col-md-6 col-lg-4">
                    <label class="form-label">Networks</label>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="network-eth">
                        <label class="form-check-label" for="network-eth">Ethereum</label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="network-base" checked>
                        <label class="form-check-label" for="network-base">Base</label>
                    </div>
                </div>
                
                <div class="col-md-6 col-lg-4">
                    <label class="form-label">Wallets to Check</label>
                    <input type="number" id="num-wallets" value="50" min="5" max="174" class="form-control">
                </div>
                
                <div class="col-md-6 col-lg-4">
                    <label class="form-label">Min Wallets for Alert</label>
                    <input type="number" id="min-wallets" value="2" min="1" max="20" class="form-control">
                </div>
                
                <div class="col-md-6 col-lg-4">
                    <label class="form-label">Min ETH Spent</label>
                    <input type="number" id="min-eth" value="0.5" step="0.1" min="0.1" class="form-control">
                </div>
                
                <div class="col-md-6 col-lg-4">
                    <label class="form-label">Min Alpha Score</label>
                    <input type="number" id="min-score" value="30" min="10" max="100" class="form-control">
                </div>
            </div>
            
            <div class="form-check mt-3">
                <input class="form-check-input" type="checkbox" id="use-interval-timeframe" checked>
                <label class="form-check-label" for="use-interval-timeframe">
                    Only check new activity since last check (recommended)
                </label>
            </div>
        </div>
    </div>
</div>

<!-- Recent Alerts -->
<div class="row">
    <div class="col-12">
        <div class="crypto-card p-4">
            <h3 class="mb-3">Recent Alerts</h3>
            <div id="alerts-container">
                <p class="text-muted">No alerts yet.</p>
            </div>
        </div>
    </div>
</div>

<!-- Toast Container -->
<div id="toast-container" class="toast-container"></div>
{% endblock %}

{% block scripts %}
<script>
// Complete JavaScript for monitor.html
let isMonitorRunning = false;
let autoScroll = true;
let consolePaused = false;
let consoleBuffer = [];
let apiCallsInProgress = new Set();
let alertRefreshInterval;
let lastAlertCount = 0;
let isRefreshing = false;
let alertsLoaded = false;

// Enhanced API call function with better error handling
async function makeApiCall(url, options = {}) {
    const requestId = Date.now() + Math.random();
    
    try {
        console.log(`[API] Starting call to: ${url}`);
        apiCallsInProgress.add(requestId);
        
        const response = await fetch(url, {
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
                ...options.headers
            },
            ...options
        });

        console.log(`[API] Response status: ${response.status} for ${url}`);

        if (!response.ok) {
            let errorText = '';
            try {
                errorText = await response.text();
            } catch (e) {
                errorText = 'Could not read error response';
            }
            
            throw new Error(`HTTP ${response.status}: ${response.statusText}. Response: ${errorText.substring(0, 200)}`);
        }

        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
            const text = await response.text();
            console.error(`[API] Non-JSON response from ${url}:`, text);
            
            if (text.includes('<!DOCTYPE') || text.includes('<html')) {
                throw new Error(`Server returned HTML error page instead of JSON. This usually indicates a server error or incorrect endpoint. Check server logs.`);
            }
            
            throw new Error(`Expected JSON but got ${contentType}. Response: ${text.substring(0, 200)}...`);
        }

        const data = await response.json();
        console.log(`[API] Success for ${url}:`, data);
        return data;

    } catch (error) {
        console.error(`[API] Failed for ${url}:`, error);
        
        if (error.message.includes('Failed to fetch')) {
            error.message = `Network error: Could not connect to server. Check if the server is running on the correct port.`;
        } else if (error.message.includes('HTML error page')) {
            error.message = `Server error: The monitor API endpoint returned an error page. Check server logs for details.`;
        }
        
        throw error;
    } finally {
        apiCallsInProgress.delete(requestId);
    }
}

// Enhanced error display function
function showApiError(endpoint, error, containerId = null) {
    const errorHtml = `
        <div class="error-message">
            <strong>‚ùå API Error (${endpoint}):</strong><br>
            ${error.message}<br>
            <small>
                <strong>Troubleshooting:</strong><br>
                ‚Ä¢ Check if the FastAPI server is running<br>
                ‚Ä¢ Verify the monitor endpoints are configured<br>
                ‚Ä¢ Check server console for error details<br>
                ‚Ä¢ Try refreshing the page<br>
            </small>
            <button class="retry-button" onclick="retryApiCall('${endpoint}', '${containerId}')">
                üîÑ Retry
            </button>
        </div>
    `;
    
    if (containerId) {
        const container = document.getElementById(containerId);
        if (container) {
            container.innerHTML = errorHtml;
        }
    }
    
    log(`‚ùå API Error (${endpoint}): ${error.message}`, 'error');
}

// Enhanced logging with different types and formatting
function log(message, type = 'info', showTimestamp = true) {
    console.log(`[Monitor] ${message}`);
    
    if (consolePaused) {
        consoleBuffer.push({message, type, showTimestamp, timestamp: new Date()});
        return;
    }
    
    const output = document.getElementById('console-output');
    if (!output) return;
    
    const line = document.createElement('div');
    line.className = `console-line ${type}`;
    
    let formattedMessage = message;
    if (showTimestamp) {
        const timestamp = new Date().toLocaleTimeString();
        formattedMessage = `[${timestamp}] ${message}`;
    }
    
    // Handle special formatting for monitor output
    if (message.includes('='.repeat(60))) {
        line.className = 'console-line banner';
        formattedMessage = message;
    } else if (message.includes('üöÄ') || message.includes('üîç') || message.includes('üìä')) {
        line.className = 'console-line highlight';
    } else if (message.includes('Progress:') || message.includes('[')) {
        line.className = 'console-line progress';
    }
    
    line.textContent = formattedMessage;
    output.appendChild(line);
    
    // Auto-scroll if enabled
    if (autoScroll) {
        output.scrollTop = output.scrollHeight;
    }
    
    // Keep only last 1000 lines for performance
    const lines = output.children;
    if (lines.length > 1000) {
        for (let i = 0; i < 100; i++) {
            output.removeChild(lines[0]);
        }
    }
}

// Helper function to show toast notifications
function showToast(message, type = 'info') {
    const toastContainer = document.getElementById('toast-container');
    if (!toastContainer) {
        // Create toast container if it doesn't exist
        const container = document.createElement('div');
        container.id = 'toast-container';
        container.className = 'toast-container position-fixed top-0 end-0 p-3';
        container.style.zIndex = '9999';
        document.body.appendChild(container);
    }
    
    const toastId = 'toast-' + Date.now();
    const bgClass = type === 'success' ? 'bg-success' : type === 'error' ? 'bg-danger' : 'bg-primary';
    
    const toastHtml = `
        <div id="${toastId}" class="toast align-items-center text-white ${bgClass} border-0" role="alert" aria-live="assertive" aria-atomic="true">
            <div class="d-flex">
                <div class="toast-body">
                    ${message}
                </div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
            </div>
        </div>
    `;
    
    document.getElementById('toast-container').insertAdjacentHTML('beforeend', toastHtml);
    
    const toastElement = document.getElementById(toastId);
    if (window.bootstrap && window.bootstrap.Toast) {
        const toast = new bootstrap.Toast(toastElement, { delay: 3000 });
        toast.show();
        
        // Remove toast element after it's hidden
        toastElement.addEventListener('hidden.bs.toast', () => {
            toastElement.remove();
        });
    } else {
        // Fallback if Bootstrap is not available
        setTimeout(() => {
            toastElement.style.display = 'none';
            setTimeout(() => toastElement.remove(), 500);
        }, 3000);
    }
}

function getValidatedEthValue(alert) {
    if (!alert || !alert.data) {
        console.warn('‚ö†Ô∏è Alert missing data:', alert);
        return 0;
    }
    
    // Try different possible ETH value fields
    let ethValue = 0;
    
    if (alert.alert_type === 'sell_pressure') {
        // For sell pressure alerts, try these fields in order
        ethValue = alert.data.total_estimated_eth || 
                  alert.data.total_eth_value || 
                  alert.data.total_eth_spent || 
                  0;
    } else {
        // For buy/new token alerts, try these fields in order
        ethValue = alert.data.total_eth_spent || 
                  alert.data.total_eth_value || 
                  alert.data.total_estimated_eth || 
                  0;
    }
    
    // Convert to number and validate
    ethValue = parseFloat(ethValue) || 0;
    
    // Log suspicious values for debugging
    if (ethValue > 100) {
        console.warn(`‚ö†Ô∏è Suspiciously high ETH value for ${alert.token}:`, {
            alertType: alert.alert_type,
            ethValue: ethValue,
            walletCount: alert.data?.wallet_count,
            rawData: alert.data
        });
    }
    
    // If the value seems unreasonably high, try to calculate a more reasonable estimate
    if (ethValue > 50 && alert.data?.wallet_count === 1) {
        // For single wallet with very high value, it might be a calculation error
        // Try to estimate based on typical transaction values
        const estimatedValue = Math.min(ethValue, 10); // Cap at 10 ETH for single wallet
        
        console.warn(`üîß Capping ETH value for ${alert.token} from ${ethValue} to ${estimatedValue}`);
        return estimatedValue;
    }
    
    return ethValue;
}

// Helper function to format ETH value for display
function formatEthValue(ethValue) {
    if (ethValue === 0) {
        return '0.0000 ETH';
    }
    
    if (ethValue < 0.0001) {
        return '<0.0001 ETH';
    }
    
    if (ethValue < 1) {
        return `${ethValue.toFixed(4)} ETH`;
    }
    
    if (ethValue < 10) {
        return `${ethValue.toFixed(3)} ETH`;
    }
    
    if (ethValue < 100) {
        return `${ethValue.toFixed(2)} ETH`;
    }
    
    // For very high values, show with warning indicator
    return `${ethValue.toFixed(1)} ETH ‚ö†Ô∏è`;
}

// All missing helper functions for the alerts system

// Helper function to get validated ETH value with proper fallbacks
function getValidatedEthValue(alert) {
    if (!alert || !alert.data) {
        console.warn('‚ö†Ô∏è Alert missing data:', alert);
        return 0;
    }
    
    // Try different possible ETH value fields
    let ethValue = 0;
    
    if (alert.alert_type === 'sell_pressure') {
        // For sell pressure alerts, try these fields in order
        ethValue = alert.data.total_estimated_eth || 
                  alert.data.total_eth_value || 
                  alert.data.total_eth_spent || 
                  0;
    } else {
        // For buy/new token alerts, try these fields in order
        ethValue = alert.data.total_eth_spent || 
                  alert.data.total_eth_value || 
                  alert.data.total_estimated_eth || 
                  0;
    }
    
    // Convert to number and validate
    ethValue = parseFloat(ethValue) || 0;
    
    // Log suspicious values for debugging
    if (ethValue > 100) {
        console.warn(`‚ö†Ô∏è Suspiciously high ETH value for ${alert.token}:`, {
            alertType: alert.alert_type,
            ethValue: ethValue,
            walletCount: alert.data?.wallet_count,
            rawData: alert.data
        });
    }
    
    // If the value seems unreasonably high, try to calculate a more reasonable estimate
    if (ethValue > 50 && alert.data?.wallet_count === 1) {
        // For single wallet with very high value, it might be a calculation error
        // Try to estimate based on typical transaction values
        const estimatedValue = Math.min(ethValue, 10); // Cap at 10 ETH for single wallet
        
        console.warn(`üîß Capping ETH value for ${alert.token} from ${ethValue} to ${estimatedValue}`);
        return estimatedValue;
    }
    
    return ethValue;
}

// Helper function to format ETH value for display
function formatEthValue(ethValue) {
    if (ethValue === 0) {
        return '0.0000 ETH';
    }
    
    if (ethValue < 0.0001) {
        return '<0.0001 ETH';
    }
    
    if (ethValue < 1) {
        return `${ethValue.toFixed(4)} ETH`;
    }
    
    if (ethValue < 10) {
        return `${ethValue.toFixed(3)} ETH`;
    }
    
    if (ethValue < 100) {
        return `${ethValue.toFixed(2)} ETH`;
    }
    
    // For very high values, show with warning indicator
    return `${ethValue.toFixed(1)} ETH ‚ö†Ô∏è`;
}

// Helper function to get transaction count with proper fallbacks
function getTransactionCount(alert) {
    if (!alert || !alert.data) return 0;
    
    // Try different possible transaction count fields
    const transactionCount = alert.data.total_purchases || 
                           alert.data.total_sells || 
                           alert.data.total_transactions ||
                           alert.data.transaction_count ||
                           0;
    
    return parseInt(transactionCount) || 0;
}

// Utility functions for alert display
function getAlertClass(alert) {
    if (alert.confidence === 'HIGH') return 'high-confidence';
    if (alert.confidence === 'MEDIUM') return 'medium-confidence';
    if (alert.alert_type === 'sell_pressure') return 'sell-pressure';
    return '';
}

function getAlertEmoji(alert) {
    switch (alert.alert_type) {
        case 'new_token': return 'üÜï';
        case 'high_activity': return 'üìà';
        case 'sell_pressure': return 'üìâ';
        default: return 'üîî';
    }
}

function getConfidenceBadge(alert) {
    const confidence = alert.confidence || 'LOW';
    const colors = {
        'HIGH': 'bg-danger',
        'MEDIUM': 'bg-warning',
        'LOW': 'bg-secondary'
    };
    const emojis = {
        'HIGH': 'üî•',
        'MEDIUM': '‚ö†Ô∏è',
        'LOW': '‚ÑπÔ∏è'
    };
    
    return `<span class="badge ${colors[confidence]} ms-2">${emojis[confidence]} ${confidence}</span>`;
}

function startAlertRefresh() {
    if (alertRefreshInterval) {
        clearInterval(alertRefreshInterval);
    }
    
    console.log('üîÑ Starting alert auto-refresh');
    
    alertRefreshInterval = setInterval(async () => {
        if (isMonitorRunning && !isRefreshing) {
            try {
                isRefreshing = true;
                
                // Get live updates
                const updates = await makeApiCall('/api/monitor/live-updates');
                
                // Check if we have new alerts
                const currentAlertCount = updates.stats?.total_alerts || 0;
                if (currentAlertCount > lastAlertCount) {
                    const newAlerts = currentAlertCount - lastAlertCount;
                    log(`üîî ${newAlerts} new alert(s) detected! Refreshing display...`, 'success');
                    
                    // Refresh the alerts display
                    await loadAlerts();
                    lastAlertCount = currentAlertCount;
                    
                    // Show toast notification
                    showToast(`${newAlerts} new alert(s) found!`, 'success');
                }
                
                // Update stats if needed
                if (updates.stats) {
                    const totalAlertsElement = document.getElementById('total-alerts');
                    const knownTokensElement = document.getElementById('known-tokens');
                    
                    if (totalAlertsElement) {
                        totalAlertsElement.textContent = updates.stats.total_alerts || 0;
                    }
                    if (knownTokensElement) {
                        knownTokensElement.textContent = updates.stats.known_tokens || 0;
                    }
                }
                
                // Update current check status
                if (updates.current_check) {
                    const checkInfo = updates.current_check;
                    log(`üîÑ Analysis in progress: ${checkInfo.type} (${checkInfo.networks.join(', ')})`, 'progress');
                }
                
            } catch (error) {
                // Silently handle errors to avoid spam, but log them
                console.debug('Live update failed:', error.message);
            } finally {
                isRefreshing = false;
            }
        }
    }, 3000); // Check every 3 seconds when monitor is running
}

function stopAlertRefresh() {
    if (alertRefreshInterval) {
        clearInterval(alertRefreshInterval);
        alertRefreshInterval = null;
        console.log('üõë Stopped alert auto-refresh');
    }
}


async function loadAlerts() {
    const container = document.getElementById('alerts-container');
    if (!container) {
        console.error('‚ùå Alerts container not found');
        return;
    }
    
    try {
        // Show loading state only on first load or if no alerts are currently displayed
        if (!alertsLoaded || container.children.length === 0) {
            container.innerHTML = `
                <div class="text-center py-3" id="alerts-loading">
                    <div class="spinner-border spinner-border-sm text-primary me-2" role="status"></div>
                    <span class="text-muted">Loading alerts...</span>
                </div>
            `;
        }
        
        log('üìã Loading recent alerts...', 'info');
        const alerts = await makeApiCall('/api/monitor/alerts?limit=20');
        
        alertsLoaded = true;
        
        if (!alerts || alerts.length === 0) {
            container.innerHTML = `
                <div class="text-center py-4">
                    <i class="fas fa-bell-slash fa-2x text-muted mb-3"></i>
                    <h6 class="text-muted">No alerts yet</h6>
                    <p class="text-muted small mb-0">Start monitoring or run an immediate check to generate alerts.</p>
                </div>
            `;
            log('üìã No alerts found', 'info');
        } else {
            log(`üìã Displaying ${alerts.length} recent alerts`, 'success');
            
            let html = '';
            alerts.forEach((alert, index) => {
                const alertClass = getAlertClass(alert);
                const alertEmoji = getAlertEmoji(alert);
                const confidenceBadge = getConfidenceBadge(alert);
                const networkBadge = alert.network ? `<span class="badge bg-info ms-2">${alert.network.toUpperCase()}</span>` : '';
                
                // Get the correct score based on alert type
                const score = alert.data?.alpha_score || alert.data?.sell_score || 0;
                
                // Get ETH value with validation
                const ethValue = getValidatedEthValue(alert);
                const ethDisplay = formatEthValue(ethValue);
                
                // Get transaction count with proper fallback
                const transactionCount = getTransactionCount(alert);
                
                // Animation class for new alerts (first 3)
                const isNewAlert = index < 3 ? 'alert-new' : '';
                
                // Get contract address for links and display
                const contractAddress = alert.data?.contract_address || '';
                const tokenSymbol = alert.token || '';
                const network = alert.network || 'ethereum';
                const detailsUrl = `/token?contract=${encodeURIComponent(contractAddress)}&token=${encodeURIComponent(tokenSymbol)}&network=${network}`;
                
                // Format contract address for display
                const contractDisplay = contractAddress ? 
                    `${contractAddress.slice(0, 6)}...${contractAddress.slice(-4)}` : 
                    'N/A';
                
                // Determine explorer URL based on network
                const explorerUrl = getExplorerUrl(contractAddress, network);
                
                html += `
                    <div class="alert-item ${alertClass} ${isNewAlert}" data-alert-id="${alert.id}">
                        <div class="d-flex justify-content-between align-items-start mb-3">
                            <div class="alert-token">
                                ${alertEmoji} ${alert.token} ${networkBadge} ${confidenceBadge}
                            </div>
                            <div class="d-flex gap-2">
                                ${contractAddress ? `
                                    <a href="${detailsUrl}" target="_blank" class="btn btn-sm btn-outline-primary" title="View token details">
                                        <i class="fas fa-info-circle"></i>
                                    </a>
                                    <a href="${explorerUrl}" target="_blank" class="btn btn-sm btn-outline-info" title="View on explorer">
                                        <i class="fas fa-external-link-alt"></i>
                                    </a>
                                ` : ''}
                                <button class="btn btn-sm btn-outline-secondary" onclick="copyAlertContract('${contractAddress}')" title="Copy contract address">
                                    <i class="fas fa-copy"></i>
                                </button>
                            </div>
                        </div>
                        
                        <div class="row g-2 mb-3">
                            <div class="col-md-3 col-6">
                                <small class="text-muted">ETH Value:</small>
                                <div class="fw-bold text-success">${ethDisplay}</div>
                            </div>
                            <div class="col-md-3 col-6">
                                <small class="text-muted">Wallets:</small>
                                <div class="fw-bold text-info">${alert.data?.wallet_count || 0}</div>
                            </div>
                            <div class="col-md-3 col-6">
                                <small class="text-muted">Score:</small>
                                <div class="fw-bold text-warning">${score.toFixed(1)}</div>
                            </div>
                            <div class="col-md-3 col-6">
                                <small class="text-muted">Activity:</small>
                                <div class="small">${transactionCount} txns</div>
                            </div>
                        </div>
                        
                        <!-- Enhanced Contract Address Section -->
                        ${contractAddress ? `
                            <div class="row g-2 mb-3">
                                <div class="col-12">
                                    <div class="contract-address-section p-2 bg-dark rounded border">
                                        <div class="d-flex justify-content-between align-items-center mb-2">
                                            <small class="text-muted fw-bold">
                                                <i class="fas fa-file-contract me-1"></i>Contract Address
                                            </small>
                                            <div class="btn-group btn-group-sm" role="group">
                                                <button type="button" class="btn btn-outline-light btn-sm" onclick="copyAlertContract('${contractAddress}')" title="Copy full address">
                                                    <i class="fas fa-copy"></i>
                                                </button>
                                                <a href="${explorerUrl}" target="_blank" class="btn btn-outline-info btn-sm" title="View on ${network === 'base' ? 'BaseScan' : 'Etherscan'}">
                                                    <i class="fas fa-search"></i>
                                                </a>
                                                <a href="https://dexscreener.com/${network}/${contractAddress}" target="_blank" class="btn btn-outline-warning btn-sm" title="View on DexScreener">
                                                    <i class="fas fa-chart-line"></i>
                                                </a>
                                            </div>
                                        </div>
                                        <div class="contract-address-display">
                                            <code class="text-light user-select-all d-block p-2 bg-black rounded" style="font-size: 0.85rem; word-break: break-all; cursor: pointer;" onclick="copyAlertContract('${contractAddress}')" title="Click to copy">${contractAddress}</code>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        ` : `
                            <div class="row g-2 mb-3">
                                <div class="col-12">
                                    <div class="contract-address-section p-2 bg-secondary rounded border">
                                        <small class="text-muted">
                                            <i class="fas fa-exclamation-triangle me-1"></i>Contract address not available
                                        </small>
                                    </div>
                                </div>
                            </div>
                        `}
                        
                        <div class="row g-2 mb-2">
                            <div class="col-md-6">
                                <small class="text-muted">Platforms/Methods:</small>
                                <div class="small">${(alert.data?.platforms || alert.data?.methods || []).slice(0, 3).join(', ') || 'Unknown'}</div>
                            </div>
                            <div class="col-md-6">
                                <small class="text-muted">Alert Type:</small>
                                <div class="small text-capitalize">${alert.alert_type?.replace('_', ' ') || 'Unknown'}</div>
                            </div>
                        </div>
                        
                        ${ethValue > 10 ? `
                            <div class="alert alert-warning py-2 mb-2">
                                <small><i class="fas fa-exclamation-triangle me-1"></i>
                                High ETH value detected (${ethValue.toFixed(4)} ETH) - please verify data accuracy</small>
                            </div>
                        ` : ''}
                        
                        <div class="d-flex justify-content-between align-items-center">
                            <small class="text-muted">
                                üïê ${new Date(alert.timestamp).toLocaleString()}
                            </small>
                            <small class="text-muted">
                                ID: ${alert.id?.slice(-8) || 'N/A'}
                            </small>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
            
            // Add CSS for new alert animation if not exists
            ensureAlertAnimationCSS();
        }
        
        log('‚úÖ Alerts loaded successfully', 'success');
        
    } catch (error) {
        console.error('‚ùå Error loading alerts:', error);
        alertsLoaded = false;
        
        const errorHtml = `
            <div class="error-message">
                <strong>‚ùå Failed to load alerts:</strong><br>
                ${error.message}<br>
                <small class="d-block mt-2">
                    <strong>Troubleshooting:</strong><br>
                    ‚Ä¢ Check if the monitor API is running<br>
                    ‚Ä¢ Verify the alerts endpoint is working<br>
                    ‚Ä¢ Try refreshing the page<br>
                </small>
                <button class="retry-button mt-2" onclick="retryLoadAlerts()">
                    üîÑ Retry Loading Alerts
                </button>
            </div>
        `;
        
        container.innerHTML = errorHtml;
        log(`‚ùå Failed to load alerts: ${error.message}`, 'error');
    }
}

// Helper function to get explorer URL based on network
function getExplorerUrl(contractAddress, network) {
    if (!contractAddress) return '#';
    
    const explorers = {
        'ethereum': `https://etherscan.io/address/${contractAddress}`,
        'base': `https://basescan.org/address/${contractAddress}`,
        'arbitrum': `https://arbiscan.io/address/${contractAddress}`,
        'polygon': `https://polygonscan.com/address/${contractAddress}`
    };
    
    return explorers[network] || explorers['ethereum'];
}

// Enhanced copyAlertContract function with better feedback
function copyAlertContract(contractAddress) {
    if (!contractAddress || contractAddress === 'N/A') {
        showToast('No contract address available', 'error');
        return;
    }
    
    navigator.clipboard.writeText(contractAddress).then(() => {
        showToast(`Contract address copied! ${contractAddress.slice(0, 10)}...`, 'success');
        log(`üìã Copied contract address: ${contractAddress}`, 'info');
        
        // Visual feedback on the copied element
        const codeElements = document.querySelectorAll('code');
        codeElements.forEach(el => {
            if (el.textContent === contractAddress) {
                el.style.backgroundColor = 'rgba(40, 167, 69, 0.3)';
                setTimeout(() => {
                    el.style.backgroundColor = '';
                }, 1000);
            }
        });
        
    }).catch(err => {
        console.error('Failed to copy contract address:', err);
        showToast('Failed to copy address', 'error');
    });
}

// Enhanced alert animation CSS with contract address styling
function ensureAlertAnimationCSS() {
    if (!document.getElementById('alert-animation-css')) {
        const style = document.createElement('style');
        style.id = 'alert-animation-css';
        style.textContent = `
            .alert-new {
                animation: alertHighlight 3s ease-in-out;
                border-left: 4px solid #28a745 !important;
            }
            @keyframes alertHighlight {
                0% { background-color: rgba(40, 167, 69, 0.3); }
                100% { background-color: transparent; }
            }
            .user-select-all {
                user-select: all;
                cursor: pointer;
                transition: background-color 0.3s ease;
            }
            .user-select-all:hover {
                background-color: rgba(255, 255, 255, 0.1) !important;
            }
            .contract-address-section {
                border-left: 3px solid #007bff !important;
                transition: all 0.3s ease;
            }
            .contract-address-section:hover {
                border-left-color: #ffc107 !important;
                background-color: rgba(255, 193, 7, 0.1) !important;
            }
            .contract-address-display code {
                transition: all 0.3s ease;
            }
            .contract-address-display code:hover {
                background-color: rgba(0, 123, 255, 0.2) !important;
                transform: scale(1.02);
            }
            .btn-group-sm .btn {
                font-size: 0.75rem;
                padding: 0.25rem 0.5rem;
            }
            .alert-item {
                transition: all 0.3s ease;
            }
            .alert-item:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            }
        `;
        document.head.appendChild(style);
    }
}

// Utility functions for alert display
function getAlertClass(alert) {
    if (alert.confidence === 'HIGH') return 'high-confidence';
    if (alert.confidence === 'MEDIUM') return 'medium-confidence';
    if (alert.alert_type === 'sell_pressure') return 'sell-pressure';
    return '';
}

function getAlertEmoji(alert) {
    switch (alert.alert_type) {
        case 'new_token': return 'üÜï';
        case 'high_activity': return 'üìà';
        case 'sell_pressure': return 'üìâ';
        default: return 'üîî';
    }
}

function getConfidenceBadge(alert) {
    const confidence = alert.confidence || 'LOW';
    const colors = {
        'HIGH': 'bg-danger',
        'MEDIUM': 'bg-warning',
        'LOW': 'bg-secondary'
    };
    const emojis = {
        'HIGH': 'üî•',
        'MEDIUM': '‚ö†Ô∏è',
        'LOW': '‚ÑπÔ∏è'
    };
    
    return `<span class="badge ${colors[confidence]} ms-2">${emojis[confidence]} ${confidence}</span>`;
}

// Monitor control functions
async function loadStatus() {
    try {
        log('üì° Loading monitor status...', 'info');
        const data = await makeApiCall('/api/monitor/status');
        
        updateUI(data);
        
        // Show stats
        if (data.data && data.data.stats) {
            const totalAlertsElement = document.getElementById('total-alerts');
            const knownTokensElement = document.getElementById('known-tokens');
            
            if (totalAlertsElement) totalAlertsElement.textContent = data.data.stats.total_alerts || 0;
            if (knownTokensElement) knownTokensElement.textContent = data.data.stats.known_tokens || 0;
        } else if (data.stats) {
            const totalAlertsElement = document.getElementById('total-alerts');
            const knownTokensElement = document.getElementById('known-tokens');
            
            if (totalAlertsElement) totalAlertsElement.textContent = data.stats.total_alerts || 0;
            if (knownTokensElement) knownTokensElement.textContent = data.stats.known_tokens || 0;
        }
        
        log('‚úÖ Monitor status loaded successfully', 'success');
        
    } catch (error) {
        showApiError('/api/monitor/status', error);
        
        // Set default values when API fails
        const statusText = document.getElementById('status-text');
        const monitorStatus = document.getElementById('monitor-status');
        
        if (statusText) statusText.textContent = 'Status unavailable';
        if (monitorStatus) {
            monitorStatus.textContent = 'Unknown';
            monitorStatus.className = 'badge bg-danger';
        }
    }
}

async function startMonitor() {
    log('üöÄ Starting crypto monitor...', 'info');
    log('üì° Sending start request to server...', 'info');
    
    try {
        const data = await makeApiCall('/api/monitor/start', { method: 'POST' });
        
        if (data.status === 'success') {
            log('‚úÖ Monitor started successfully!', 'success');
            log('üîÑ Monitor will now check for new tokens automatically', 'info');
            log(`‚è∞ Check interval: ${data.config ? data.config.check_interval_minutes : 'Unknown'} minutes`, 'info');
            showToast('Monitor started successfully!', 'success');
        } else {
            log(`‚ùå Failed to start monitor: ${data.message}`, 'error');
            showToast('Failed to start monitor', 'error');
        }
        loadStatus();
    } catch (error) {
        log(`‚ùå Error starting monitor: ${error.message}`, 'error');
        showToast('Error starting monitor', 'error');
    }
}

async function stopMonitor() {
    log('üõë Stopping crypto monitor...', 'info');
    log('üì° Sending stop request to server...', 'info');
    
    try {
        const data = await makeApiCall('/api/monitor/stop', { method: 'POST' });
        
        if (data.status === 'success') {
            log('‚úÖ Monitor stopped successfully', 'success');
            showToast('Monitor stopped', 'success');
        } else {
            log(`‚ùå Failed to stop monitor: ${data.message}`, 'error');
            showToast('Failed to stop monitor', 'error');
        }
        loadStatus();
    } catch (error) {
        log(`‚ùå Error stopping monitor: ${error.message}`, 'error');
        showToast('Error stopping monitor', 'error');
    }
}

async function checkNow() {
    log('üîç Starting immediate check...', 'warning');
    log('üöÄ This will analyze recent wallet activity for new tokens', 'info');
    log('‚è≥ Please wait... Check will run in background', 'info');
    
    try {
        const data = await makeApiCall('/api/monitor/check-now', { method: 'POST' });
        
        if (data.status === 'success') {
            log('‚úÖ Immediate check initiated successfully!', 'success');
            log('üîç Analysis running... Results will appear shortly', 'info');
            showToast('Analysis started!', 'success');
            
            // Simulate progress updates
            setTimeout(() => log('üìä Analyzing wallet transactions...', 'progress'), 2000);
            setTimeout(() => log('üîç Checking for new token activity...', 'progress'), 5000);
            setTimeout(() => log('üìà Calculating scores...', 'progress'), 8000);
            setTimeout(() => {
                log('‚úÖ Analysis complete! Loading results...', 'success');
                loadAlerts();
                loadStatus();
            }, 12000);
        } else {
            log(`‚ùå Check failed: ${data.message}`, 'error');
            showToast('Check failed', 'error');
        }
    } catch (error) {
        log(`‚ùå Error running immediate check: ${error.message}`, 'error');
        showToast('Error running check', 'error');
    }
}

async function testConnection() {
    log('üîå Testing monitor connections...', 'info');
    log('üì° Checking API endpoints and database connectivity', 'info');
    
    try {
        const data = await makeApiCall('/api/monitor/test');
        
        if (data.status === 'success') {
            log('‚úÖ Connection test passed!', 'success');
            log(`üìä Test results: ${JSON.stringify(data.results)}`, 'info');
            showToast('Connection test passed!', 'success');
            
            // Display individual test results
            if (data.results) {
                Object.entries(data.results).forEach(([test, result]) => {
                    const status = result ? '‚úÖ' : '‚ùå';
                    log(`  ${status} ${test}: ${result ? 'OK' : 'FAILED'}`, result ? 'success' : 'error');
                });
            }
        } else {
            log(`‚ùå Connection test failed: ${data.message}`, 'error');
            showToast('Connection test failed', 'error');
        }
    } catch (error) {
        log(`‚ùå Connection test error: ${error.message}`, 'error');
        showToast('Connection test error', 'error');
    }
}

// Console functions
function clearConsole() {
    const output = document.getElementById('console-output');
    if (output) {
        output.innerHTML = '';
        log('üöÄ Monitor console ready. Click "Check Now" or "Start Monitor" to begin.');
        log('üí° Tip: Console will show detailed progress when analysis runs');
    }
}

function toggleAutoScroll() {
    autoScroll = !autoScroll;
    const toggleText = document.getElementById('scroll-toggle-text');
    if (toggleText) {
        toggleText.textContent = `Auto Scroll: ${autoScroll ? 'ON' : 'OFF'}`;
    }
    
    const output = document.getElementById('console-output');
    if (output) {
        if (autoScroll) {
            output.classList.add('auto-scroll');
            output.scrollTop = output.scrollHeight;
        } else {
            output.classList.remove('auto-scroll');
        }
    }
}

// Visual feedback functions for configuration updates
function showConfigurationStatus(status) {
    const configSection = document.querySelector('.crypto-card h3');
    if (!configSection || !configSection.textContent.includes('Configuration')) return;
    
    // Remove existing status indicators
    const existingIndicator = configSection.querySelector('.config-status');
    if (existingIndicator) {
        existingIndicator.remove();
    }
    
    let indicator = '';
    switch (status) {
        case 'updating':
            indicator = '<span class="config-status badge bg-warning ms-2">Updating...</span>';
            break;
        case 'success':
            indicator = '<span class="config-status badge bg-success ms-2">‚úì Saved</span>';
            setTimeout(() => showConfigurationStatus('clear'), 3000);
            break;
        case 'error':
            indicator = '<span class="config-status badge bg-danger ms-2">‚úó Error</span>';
            setTimeout(() => showConfigurationStatus('clear'), 5000);
            break;
        case 'clear':
            return;
    }
    
    configSection.insertAdjacentHTML('beforeend', indicator);
}

function showThresholdStatus(status) {
    // Find threshold labels and add status indicators
    const labels = document.querySelectorAll('label');
    let thresholdLabel = null;
    
    for (const label of labels) {
        if (label.textContent.includes('Min Wallets') || label.textContent.includes('Min ETH') || label.textContent.includes('Min Alpha')) {
            thresholdLabel = label.closest('.crypto-card')?.querySelector('h3');
            break;
        }
    }
    
    if (!thresholdLabel) return;
    
    // Remove existing status indicators
    const existingIndicator = thresholdLabel.querySelector('.threshold-status');
    if (existingIndicator) {
        existingIndicator.remove();
    }
    
    let indicator = '';
    switch (status) {
        case 'updating':
            indicator = '<span class="threshold-status badge bg-warning ms-2">Updating...</span>';
            break;
        case 'success':
            indicator = '<span class="threshold-status badge bg-success ms-2">‚úì Saved</span>';
            setTimeout(() => showThresholdStatus('clear'), 3000);
            break;
        case 'error':
            indicator = '<span class="threshold-status badge bg-danger ms-2">‚úó Error</span>';
            setTimeout(() => showThresholdStatus('clear'), 5000);
            break;
        case 'clear':
            return;
    }
    
    thresholdLabel.insertAdjacentHTML('beforeend', indicator);
}

// Initialize the monitor page
function initializeMonitorPage() {
    log('üåê Page loaded, initializing monitor interface...');
    
    // Start loading data
    loadStatus().then(() => {
        loadAlerts();
        log('‚úÖ Monitor page initialized successfully', 'success');
        
        // Get initial alert count
        setTimeout(async () => {
            try {
                const updates = await makeApiCall('/api/monitor/live-updates');
                lastAlertCount = updates.stats?.total_alerts || 0;
                console.log(`üìä Initial alert count: ${lastAlertCount}`);
            } catch (error) {
                console.debug('Could not get initial alert count:', error);
            }
        }, 2000);
    }).catch(error => {
        log(`‚ùå Failed to initialize monitor page: ${error.message}`, 'error');
    });
}

// Enhanced updateUI function with proper focus detection
function updateUI(response) {
    // Handle both direct data and wrapped responses
    const status = response.data || response;
    console.log('üîÑ Status updated:', status);

    const indicator = document.getElementById('status-indicator');
    const statusText = document.getElementById('status-text');
    const startBtn = document.getElementById('start-btn');
    const stopBtn = document.getElementById('stop-btn');
    const monitorStatus = document.getElementById('monitor-status');
    const consoleStatus = document.getElementById('console-status');
    
    isMonitorRunning = status.is_running;
    
    if (isMonitorRunning) {
        if (indicator) indicator.classList.add('active');
        if (statusText) statusText.textContent = 'Monitor Active';
        if (monitorStatus) {
            monitorStatus.className = 'badge bg-success';
            monitorStatus.textContent = 'Active';
        }
        if (consoleStatus) consoleStatus.style.display = 'inline-block';
        if (startBtn) startBtn.style.display = 'none';
        if (stopBtn) stopBtn.style.display = 'inline-block';
        
        // Start auto-refresh when monitor is active
        startAlertRefresh();
        log('‚úÖ Monitor is running - auto-refresh enabled', 'success');
    } else {
        if (indicator) indicator.classList.remove('active');
        if (statusText) statusText.textContent = 'Monitor Inactive';
        if (monitorStatus) {
            monitorStatus.className = 'badge bg-secondary';
            monitorStatus.textContent = 'Inactive';
        }
        if (consoleStatus) consoleStatus.style.display = 'none';
        if (startBtn) startBtn.style.display = 'inline-block';
        if (stopBtn) stopBtn.style.display = 'none';
        
        // Stop auto-refresh when monitor is inactive
        stopAlertRefresh();
        log('üõë Monitor stopped - auto-refresh disabled', 'info');
    }
    
    if (status.last_check) {
        const lastCheck = new Date(status.last_check);
        const lastCheckElement = document.getElementById('last-check');
        if (lastCheckElement) {
            lastCheckElement.textContent = lastCheck.toLocaleTimeString();
        }
    }
    
    if (status.next_check && isMonitorRunning) {
        const nextCheck = new Date(status.next_check);
        const nextCheckElement = document.getElementById('next-check');
        if (nextCheckElement) {
            nextCheckElement.textContent = nextCheck.toLocaleTimeString();
        }
        
        // Calculate time until next check
        const now = new Date();
        const timeUntil = nextCheck - now;
        if (timeUntil > 0) {
            const minutes = Math.floor(timeUntil / 60000);
            const seconds = Math.floor((timeUntil % 60000) / 1000);
            log(`‚è∞ Next check in ${minutes}m ${seconds}s`, 'info');
        }
    } else {
        const nextCheckElement = document.getElementById('next-check');
        if (nextCheckElement) {
            nextCheckElement.textContent = '-';
        }
    }
    
    // FIXED: Better input focus detection and user interaction tracking
    updateConfigurationFields(status.config);
    updateThresholdFields(status.alert_thresholds);
}

// New helper function to safely update configuration fields
function updateConfigurationFields(config) {
    if (!config) return;
    
    const fields = [
        { id: 'interval-select', value: config.check_interval_minutes || 60 },
        { id: 'num-wallets', value: config.num_wallets || 50 },
        { id: 'use-interval-timeframe', value: config.use_interval_for_timeframe !== false, type: 'checkbox' }
    ];
    
    fields.forEach(field => {
        const element = document.getElementById(field.id);
        if (element && !isUserInteracting(element)) {
            if (field.type === 'checkbox') {
                element.checked = field.value;
            } else {
                element.value = field.value;
            }
        }
    });
    
    // Update network checkboxes (less likely to be actively edited)
    if (config.networks) {
        const networkEth = document.getElementById('network-eth');
        const networkBase = document.getElementById('network-base');
        
        if (networkEth && !isUserInteracting(networkEth)) {
            networkEth.checked = config.networks.includes('ethereum');
        }
        if (networkBase && !isUserInteracting(networkBase)) {
            networkBase.checked = config.networks.includes('base');
        }
    }
}

// New helper function to safely update threshold fields
function updateThresholdFields(thresholds) {
    if (!thresholds) return;
    
    const fields = [
        { id: 'min-wallets', value: thresholds.min_wallets || 2 },
        { id: 'min-eth', value: thresholds.min_eth_total || 0.5 },
        { id: 'min-score', value: thresholds.min_alpha_score || 30 }
    ];
    
    fields.forEach(field => {
        const element = document.getElementById(field.id);
        if (element && !isUserInteracting(element)) {
            element.value = field.value;
        }
    });
}

// Enhanced function to detect if user is currently interacting with an element
function isUserInteracting(element) {
    if (!element) return false;
    
    // Check if element has focus
    if (document.activeElement === element) {
        return true;
    }
    
    // Check if element was recently interacted with
    const lastInteraction = element.dataset.lastInteraction;
    if (lastInteraction) {
        const timeSinceInteraction = Date.now() - parseInt(lastInteraction);
        // Don't update for 5 seconds after user interaction
        if (timeSinceInteraction < 5000) {
            return true;
        }
    }
    
    return false;
}

// Track user interactions to prevent overriding values
function trackUserInteraction(element) {
    if (element) {
        element.dataset.lastInteraction = Date.now().toString();
    }
}

// Enhanced setupConfigurationEventListeners with interaction tracking
function setupConfigurationEventListeners() {
    // Configuration section event listeners
    const configElements = [
        'interval-select',
        'network-eth', 
        'network-base',
        'num-wallets',
        'use-interval-timeframe'
    ];
    
    // Threshold section event listeners
    const thresholdElements = [
        'min-wallets',
        'min-eth',
        'min-score'
    ];
    
    // Setup config listeners with interaction tracking
    configElements.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            // Track focus events
            element.addEventListener('focus', () => {
                trackUserInteraction(element);
                console.log(`üìù User focused on ${id}`);
            });
            
            // Track input events
            element.addEventListener('input', () => {
                trackUserInteraction(element);
                console.log(`‚úèÔ∏è User input on ${id}`);
            });
            
            // Track change events
            element.addEventListener('change', () => {
                trackUserInteraction(element);
                console.log(`üîÑ User changed ${id}`);
                updateConfig();
            });
            
            // For number inputs, add debounced input listener
            if (element.type === 'number') {
                element.addEventListener('input', debounce(() => {
                    trackUserInteraction(element);
                    updateConfig();
                }, 1000));
            }
        }
    });
    
    // Setup threshold listeners with interaction tracking
    thresholdElements.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            // Track focus events
            element.addEventListener('focus', () => {
                trackUserInteraction(element);
                console.log(`üìù User focused on ${id}`);
            });
            
            // Track input events
            element.addEventListener('input', () => {
                trackUserInteraction(element);
                console.log(`‚úèÔ∏è User input on ${id}`);
            });
            
            // Track change events
            element.addEventListener('change', () => {
                trackUserInteraction(element);
                console.log(`üîÑ User changed ${id}`);
                updateThresholds();
            });
            
            // For number inputs, add debounced input listener
            if (element.type === 'number') {
                element.addEventListener('input', debounce(() => {
                    trackUserInteraction(element);
                    updateThresholds();
                }, 1000));
            }
        }
    });
    
    console.log('‚úÖ Configuration event listeners setup complete with interaction tracking');
}

// Enhanced updateConfig function with better state management
async function updateConfig() {
    // Check if any config elements are currently being interacted with
    const configElementIds = ['interval-select', 'network-eth', 'network-base', 'num-wallets', 'use-interval-timeframe'];
    const hasActiveInteraction = configElementIds.some(id => {
        const element = document.getElementById(id);
        return element && isUserInteracting(element);
    });
    
    if (hasActiveInteraction) {
        console.log('‚è≥ Delaying config update - user is actively editing');
        // Retry after user interaction period
        setTimeout(updateConfig, 1000);
        return;
    }
    
    const networks = [];
    const networkEth = document.getElementById('network-eth');
    const networkBase = document.getElementById('network-base');
    
    if (networkEth && networkEth.checked) networks.push('ethereum');
    if (networkBase && networkBase.checked) networks.push('base');
    
    const intervalSelect = document.getElementById('interval-select');
    const numWallets = document.getElementById('num-wallets');
    const useIntervalTimeframe = document.getElementById('use-interval-timeframe');
    
    const config = {
        check_interval_minutes: parseInt(intervalSelect?.value || 60),
        networks: networks,
        num_wallets: parseInt(numWallets?.value || 50),
        use_interval_for_timeframe: useIntervalTimeframe?.checked !== false
    };
    
    // Validate configuration
    if (networks.length === 0) {
        showToast('Please select at least one network', 'error');
        return;
    }
    
    if (config.num_wallets < 5 || config.num_wallets > 174) {
        showToast('Number of wallets must be between 5 and 174', 'error');
        return;
    }
    
    log(`‚öôÔ∏è Updating configuration...`, 'info');
    log(`üìä New settings: ${networks.join(', ')} networks, ${config.num_wallets} wallets, ${config.check_interval_minutes}min interval`, 'info');
    
    // Show visual feedback
    showConfigurationStatus('updating');
    
    try {
        const data = await makeApiCall('/api/monitor/config', {
            method: 'POST',
            body: JSON.stringify(config)
        });
        
        if (data.status === 'success') {
            log('‚úÖ Configuration updated successfully', 'success');
            showToast('Configuration updated successfully', 'success');
            showConfigurationStatus('success');
            
            // Don't reload status immediately to avoid overriding user changes
            // Just mark that we don't need to update these fields for a while
            configElementIds.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.dataset.lastInteraction = Date.now().toString();
                }
            });
        } else {
            log(`‚ùå Config update failed: ${data.message}`, 'error');
            showToast(`Config update failed: ${data.message}`, 'error');
            showConfigurationStatus('error');
        }
    } catch (error) {
        log(`‚ùå Error updating config: ${error.message}`, 'error');
        showToast('Error updating configuration', 'error');
        showConfigurationStatus('error');
    }
}

// Enhanced updateThresholds function with better state management
async function updateThresholds() {
    // Check if any threshold elements are currently being interacted with
    const thresholdElementIds = ['min-wallets', 'min-eth', 'min-score'];
    const hasActiveInteraction = thresholdElementIds.some(id => {
        const element = document.getElementById(id);
        return element && isUserInteracting(element);
    });
    
    if (hasActiveInteraction) {
        console.log('‚è≥ Delaying threshold update - user is actively editing');
        // Retry after user interaction period
        setTimeout(updateThresholds, 1000);
        return;
    }
    
    const minWallets = document.getElementById('min-wallets');
    const minEth = document.getElementById('min-eth');
    const minScore = document.getElementById('min-score');
    
    const thresholds = {
        min_wallets: parseInt(minWallets?.value || 2),
        min_eth_total: parseFloat(minEth?.value || 0.5),
        min_alpha_score: parseFloat(minScore?.value || 30),
        min_sell_score: 25.0,
        min_transactions: 3,
        filter_stablecoins: true
    };
    
    // Validate thresholds
    if (thresholds.min_wallets < 1 || thresholds.min_wallets > 20) {
        showToast('Min wallets must be between 1 and 20', 'error');
        return;
    }
    
    if (thresholds.min_eth_total < 0.01 || thresholds.min_eth_total > 100) {
        showToast('Min ETH must be between 0.01 and 100', 'error');
        return;
    }
    
    if (thresholds.min_alpha_score < 10 || thresholds.min_alpha_score > 100) {
        showToast('Min alpha score must be between 10 and 100', 'error');
        return;
    }
    
    log(`üéØ Updating alert thresholds...`, 'info');
    log(`üìä New thresholds: ${thresholds.min_wallets} wallets, ${thresholds.min_eth_total} ETH, Œ±‚â•${thresholds.min_alpha_score}`, 'info');
    
    // Show visual feedback
    showThresholdStatus('updating');
    
    try {
        const data = await makeApiCall('/api/monitor/thresholds', {
            method: 'POST',
            body: JSON.stringify(thresholds)
        });
        
        if (data.status === 'success') {
            log('‚úÖ Alert thresholds updated successfully', 'success');
            showToast('Alert thresholds updated successfully', 'success');
            showThresholdStatus('success');
            
            // Mark threshold fields as recently updated
            thresholdElementIds.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.dataset.lastInteraction = Date.now().toString();
                }
            });
        } else {
            log(`‚ùå Threshold update failed: ${data.message}`, 'error');
            showToast(`Threshold update failed: ${data.message}`, 'error');
            showThresholdStatus('error');
        }
    } catch (error) {
        log(`‚ùå Error updating thresholds: ${error.message}`, 'error');
        showToast('Error updating thresholds', 'error');
        showThresholdStatus('error');
    }
}

// Debounce function to prevent too many API calls
function debounce(func, delay) {
    let timeoutId;
    return function (...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
}

// Additional utility functions
function retryApiCall(endpoint, containerId) {
    log(`üîÑ Retrying API call to ${endpoint}...`, 'info');
    
    switch (endpoint) {
        case '/api/monitor/status':
            loadStatus();
            break;
        case '/api/monitor/alerts':
            loadAlerts();
            break;
        case '/api/monitor/config':
            loadStatus();
            break;
        default:
            log(`‚ö†Ô∏è Don't know how to retry ${endpoint}`, 'warning');
    }
}

function exportConsoleLog() {
    const output = document.getElementById('console-output');
    if (!output) return;
    
    const lines = Array.from(output.children).map(line => line.textContent).join('\n');
    
    const blob = new Blob([lines], { type: 'text/plain' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `monitor-log-${new Date().toISOString().split('T')[0]}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    window.URL.revokeObjectURL(url);
    
    log('üìÅ Console log exported successfully', 'success');
}

function pauseConsole() {
    consolePaused = !consolePaused;
    const pauseIcon = document.getElementById('pause-icon');
    const pauseText = document.getElementById('pause-text');
    
    if (pauseIcon && pauseText) {
        if (consolePaused) {
            pauseIcon.className = 'fas fa-play';
            pauseText.textContent = 'Resume';
            log('‚è∏Ô∏è Console output paused', 'warning');
        } else {
            pauseIcon.className = 'fas fa-pause';
            pauseText.textContent = 'Pause';
            log('‚ñ∂Ô∏è Console output resumed', 'success');
            
            // Flush buffer
            while (consoleBuffer.length > 0) {
                const buffered = consoleBuffer.shift();
                log(buffered.message, buffered.type, buffered.showTimestamp);
            }
        }
    }
}

// Initialize when page loads
document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ Monitor page auto-refresh initialized');
    
    // Initialize the monitor page
    initializeMonitorPage();
    
    // Add event listeners for configuration changes
    setupConfigurationEventListeners();
    
    // Welcome message with tips after a delay
    setTimeout(() => {
        const output = document.getElementById('console-output');
        if (output && output.children.length <= 2) {
            log('üí° Pro Tips:', 'info');
            log('  ‚Ä¢ Ctrl+Enter: Run immediate check', 'info');
            log('  ‚Ä¢ Ctrl+Shift+C: Clear console', 'info');
            log('  ‚Ä¢ Auto-scroll can be toggled with the button above', 'info');
            log('  ‚Ä¢ Console output can be paused and exported', 'info');
        }
    }, 3000);
});

// Auto-refresh status every 30 seconds
setInterval(() => {
    if (isMonitorRunning) {
        loadStatus();
        log('üîÑ Checking monitor status...', 'info');
    }
}, 30000);

// Keyboard shortcuts
document.addEventListener('keydown', function(e) {
    // Ctrl/Cmd + Enter to run immediate check
    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
        e.preventDefault();
        checkNow();
        log('‚å®Ô∏è Keyboard shortcut: Immediate check triggered', 'info');
    }
    
    // Ctrl/Cmd + Shift + C to clear console
    if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'C') {
        e.preventDefault();
        clearConsole();
        log('‚å®Ô∏è Keyboard shortcut: Console cleared', 'info');
    }
});

// Page visibility API to pause updates when tab is not active
document.addEventListener('visibilitychange', function() {
    if (document.hidden) {
        log('üëÅÔ∏è Tab hidden, reducing update frequency', 'info');
    } else {
        log('üëÅÔ∏è Tab visible, resuming normal updates', 'info');
        loadStatus(); // Immediate update when tab becomes visible
    }
});

// Cleanup on page unload
window.addEventListener('beforeunload', function() {
    stopAlertRefresh();
});

// Debug function for troubleshooting
window.debugMonitorPage = function() {
    console.log('=== Monitor Page Debug Info ===');
    console.log('API calls in progress:', apiCallsInProgress.size);
    console.log('Monitor running:', isMonitorRunning);
    console.log('Auto scroll:', autoScroll);
    console.log('Console paused:', consolePaused);
    console.log('Buffer size:', consoleBuffer.length);
    
    // Test all monitor endpoints
    const endpoints = [
        '/api/monitor/status',
        '/api/monitor/config',
        '/api/monitor/alerts',
        '/api/monitor/test'
    ];
    
    console.log('Testing monitor endpoints...');
    endpoints.forEach(async (endpoint) => {
        try {
            const response = await fetch(endpoint);
            console.log(`${endpoint}: ${response.status} ${response.statusText}`);
            if (!response.ok) {
                const text = await response.text();
                console.log(`  Error response:`, text.substring(0, 200));
            }
        } catch (error) {
            console.error(`${endpoint}: ERROR -`, error.message);
        }
    });
};

console.log('üí° Debug function available: debugMonitorPage()');

// Update current time function if element exists
function updateTime() {
    const now = new Date();
    const timeElement = document.getElementById('current-time');
    if (timeElement) {
        timeElement.textContent = now.toLocaleString();
    }
}

// Start time updates if element exists
if (document.getElementById('current-time')) {
    updateTime();
    setInterval(updateTime, 1000);
}
</script>
{% endblock %}