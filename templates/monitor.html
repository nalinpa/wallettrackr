{% extends "base.html" %}

{% block title %}Monitor - Crypto Alpha Analysis{% endblock %}

{% block head %}
<style>
    .crypto-card {
        background: linear-gradient(145deg, #2c3e50, #34495e);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 15px;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    }
    
    .status-indicator {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: #6c757d;
        margin-right: 10px;
        display: inline-block;
    }
    
    .status-indicator.active {
        background: #28a745;
        animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
        0% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0.7); }
        70% { box-shadow: 0 0 0 10px rgba(40, 167, 69, 0); }
        100% { box-shadow: 0 0 0 0 rgba(40, 167, 69, 0); }
    }
    
    .console-output {
        background: #0a0a0a;
        border: 1px solid #333;
        border-radius: 8px;
        padding: 20px;
        font-family: 'Courier New', monospace;
        font-size: 0.9rem;
        max-height: 600px;
        overflow-y: auto;
        white-space: pre-wrap;
        word-wrap: break-word;
        position: relative;
    }
    
    .console-line {
        margin-bottom: 5px;
        padding: 2px 0;
        line-height: 1.4;
        border-radius: 3px;
        padding-left: 5px;
    }
    
    .console-line.success { 
        color: #28a745; 
        background: rgba(40, 167, 69, 0.1);
    }
    .console-line.error { 
        color: #dc3545; 
        background: rgba(220, 53, 69, 0.1);
    }
    .console-line.info { 
        color: #17a2b8; 
    }
    .console-line.warning { 
        color: #ffc107; 
        background: rgba(255, 193, 7, 0.1);
    }
    .console-line.highlight {
        color: #ff6b6b;
        background: rgba(255, 107, 107, 0.1);
        font-weight: bold;
    }
    .console-line.progress {
        color: #6c5ce7;
    }
    .console-line.banner {
        color: #fd79a8;
        font-weight: bold;
        text-align: center;
        background: rgba(253, 121, 168, 0.1);
        margin: 10px 0;
        padding: 10px;
    }
    
    .console-controls {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 10;
    }
    
    .console-controls button {
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid #555;
        color: #fff;
        padding: 5px 10px;
        margin-left: 5px;
        border-radius: 4px;
        font-size: 0.8rem;
    }
    
    .console-controls button:hover {
        background: rgba(255, 255, 255, 0.1);
    }
    
    .alert-item {
        background: rgba(0, 0, 0, 0.3);
        padding: 15px;
        margin: 10px 0;
        border-radius: 8px;
        border-left: 4px solid #28a745;
        transition: all 0.3s ease;
    }
    
    .alert-item:hover {
        background: rgba(0, 0, 0, 0.5);
        transform: translateY(-2px);
    }
    
    .alert-item.high-confidence {
        border-left-color: #dc3545;
        background: rgba(220, 53, 69, 0.1);
    }
    
    .alert-item.medium-confidence {
        border-left-color: #ffc107;
        background: rgba(255, 193, 7, 0.1);
    }
    
    .alert-item.sell-pressure {
        border-left-color: #6f42c1;
        background: rgba(111, 66, 193, 0.1);
    }
    
    .alert-token {
        font-size: 1.2rem;
        font-weight: bold;
        color: #ffc107;
        margin-bottom: 8px;
    }
    
    .alert-contract {
        font-family: 'Courier New', monospace;
        font-size: 0.85rem;
        background: rgba(0, 0, 0, 0.5);
        padding: 8px;
        border-radius: 4px;
        margin-top: 10px;
        word-break: break-all;
    }
    
    .stats-card {
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        padding: 15px;
        text-align: center;
        transition: all 0.3s ease;
    }
    
    .stats-card:hover {
        background: rgba(0, 0, 0, 0.5);
        transform: translateY(-2px);
    }
    
    .stats-number {
        font-size: 2rem;
        font-weight: bold;
        color: #28a745;
    }
    
    .auto-scroll {
        animation: scroll-indicator 1s ease-in-out infinite alternate;
    }
    
    @keyframes scroll-indicator {
        from { opacity: 0.5; }
        to { opacity: 1; }
    }

    .error-message {
        background: rgba(220, 53, 69, 0.2);
        border: 1px solid #dc3545;
        border-radius: 8px;
        padding: 15px;
        margin: 10px 0;
        color: #fff;
    }

    .loading-message {
        background: rgba(23, 162, 184, 0.2);
        border: 1px solid #17a2b8;
        border-radius: 8px;
        padding: 15px;
        margin: 10px 0;
        color: #fff;
        text-align: center;
    }

    .retry-button {
        background: #dc3545;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        margin-top: 10px;
        cursor: pointer;
    }

    .retry-button:hover {
        background: #c82333;
    }
</style>
{% endblock %}

{% block content %}
<div class="row mb-4">
    <div class="col-12">
        <div class="crypto-card p-4">
            <h3 class="mb-3">Monitor Control</h3>
            
            <div class="d-flex align-items-center mb-3">
                <span class="status-indicator" id="status-indicator"></span>
                <span id="status-text" class="me-3">Loading...</span>
                <span id="monitor-status" class="badge bg-secondary">Inactive</span>
            </div>

            <div class="d-flex flex-wrap gap-2 mb-3">
                <button class="btn btn-success" id="start-btn" onclick="startMonitor()">
                    <i class="fas fa-play me-2"></i>Start Monitor
                </button>
                <button class="btn btn-danger" id="stop-btn" onclick="stopMonitor()" style="display: none;">
                    <i class="fas fa-stop me-2"></i>Stop Monitor
                </button>
                <button class="btn btn-warning" onclick="checkNow()">
                    <i class="fas fa-search me-2"></i>Check Now
                </button>
                <button class="btn btn-info" onclick="testConnection()">
                    <i class="fas fa-vial me-2"></i>Test Connection
                </button>
                <button class="btn btn-secondary" onclick="clearConsole()">
                    <i class="fas fa-trash me-2"></i>Clear Console
                </button>
                <button class="btn btn-outline-light btn-sm" onclick="toggleAutoScroll()">
                    <i class="fas fa-arrows-alt-v me-1"></i><span id="scroll-toggle-text">Auto Scroll: ON</span>
                </button>
            </div>

            <div class="row g-3">
                <div class="col-md-3">
                    <div class="stats-card">
                        <h6 class="text-muted text-uppercase mb-1">Last Check</h6>
                        <div class="h6 text-info" id="last-check">Never</div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="stats-card">
                        <h6 class="text-muted text-uppercase mb-1">Next Check</h6>
                        <div class="h6 text-warning" id="next-check">-</div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="stats-card">
                        <h6 class="text-muted text-uppercase mb-1">Total Alerts</h6>
                        <div class="stats-number" id="total-alerts">0</div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="stats-card">
                        <h6 class="text-muted text-uppercase mb-1">Known Tokens</h6>
                        <div class="stats-number" id="known-tokens">0</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Enhanced Console Output -->
<div class="row mb-4">
    <div class="col-12">
        <div class="crypto-card p-4">
            <h3 class="mb-3">
                Real-Time Console Output
                <span class="badge bg-success ms-2" id="console-status" style="display: none;">LIVE</span>
            </h3>
            <div class="console-output" id="console-output">
                <div class="console-line info">üöÄ Monitor console ready. Click "Check Now" or "Start Monitor" to begin.</div>
                <div class="console-line info">üí° Tip: Console will show detailed progress when analysis runs</div>
            </div>
            <div class="console-controls">
                <button onclick="exportConsoleLog()">
                    <i class="fas fa-download"></i> Export
                </button>
                <button onclick="pauseConsole()">
                    <i class="fas fa-pause" id="pause-icon"></i> <span id="pause-text">Pause</span>
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Configuration -->
<div class="row mb-4">
    <div class="col-12">
        <div class="crypto-card p-4">
            <h3 class="mb-3">Configuration</h3>
            
            <div class="row g-3">
                <div class="col-md-6 col-lg-4">
                    <label class="form-label">Check Interval (minutes)</label>
                    <select id="interval-select" class="form-select" onchange="updateConfig()">
                        <option value="5">5 minutes</option>
                        <option value="15">15 minutes</option>
                        <option value="30">30 minutes</option>
                        <option value="60" selected>1 hour</option>
                        <option value="120">2 hours</option>
                        <option value="240">4 hours</option>
                    </select>
                </div>
                
                <div class="col-md-6 col-lg-4">
                    <label class="form-label">Networks</label>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="network-eth" onchange="updateConfig()">
                        <label class="form-check-label" for="network-eth">Ethereum</label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="network-base" checked onchange="updateConfig()">
                        <label class="form-check-label" for="network-base">Base</label>
                    </div>
                </div>
                
                <div class="col-md-6 col-lg-4">
                    <label class="form-label">Wallets to Check</label>
                    <input type="number" id="num-wallets" value="50" min="5" max="174" class="form-control" onchange="updateConfig()">
                </div>
                
                <div class="col-md-6 col-lg-4">
                    <label class="form-label">Min Wallets for Alert</label>
                    <input type="number" id="min-wallets" value="2" min="1" max="20" class="form-control" onchange="updateThresholds()">
                </div>
                
                <div class="col-md-6 col-lg-4">
                    <label class="form-label">Min ETH Spent</label>
                    <input type="number" id="min-eth" value="0.5" step="0.1" min="0.1" class="form-control" onchange="updateThresholds()">
                </div>
                
                <div class="col-md-6 col-lg-4">
                    <label class="form-label">Min Alpha Score</label>
                    <input type="number" id="min-score" value="30" min="10" max="100" class="form-control" onchange="updateThresholds()">
                </div>
            </div>
            
            <div class="form-check mt-3">
                <input class="form-check-input" type="checkbox" id="use-interval-timeframe" checked onchange="updateConfig()">
                <label class="form-check-label" for="use-interval-timeframe">
                    Only check new activity since last check (recommended)
                </label>
            </div>
        </div>
    </div>
</div>

<!-- Recent Alerts -->
<div class="row">
    <div class="col-12">
        <div class="crypto-card p-4">
            <h3 class="mb-3">Recent Alerts</h3>
            <div id="alerts-container">
                <p class="text-muted">No alerts yet.</p>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
let isMonitorRunning = false;
let autoScroll = true;
let consolePaused = false;
let consoleBuffer = [];
let apiCallsInProgress = new Set();

// Enhanced API call function with better error handling
async function makeApiCall(url, options = {}) {
    const requestId = Date.now() + Math.random();
    
    try {
        console.log(`[API] Starting call to: ${url}`);
        apiCallsInProgress.add(requestId);
        
        const response = await fetch(url, {
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
                ...options.headers
            },
            ...options
        });

        console.log(`[API] Response status: ${response.status} for ${url}`);

        if (!response.ok) {
            // Get error text for better debugging
            let errorText = '';
            try {
                errorText = await response.text();
            } catch (e) {
                errorText = 'Could not read error response';
            }
            
            throw new Error(`HTTP ${response.status}: ${response.statusText}. Response: ${errorText.substring(0, 200)}`);
        }

        // Check if response is JSON
        const contentType = response.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
            const text = await response.text();
            console.error(`[API] Non-JSON response from ${url}:`, text);
            
            // Check if this is an HTML error page
            if (text.includes('<!DOCTYPE') || text.includes('<html')) {
                throw new Error(`Server returned HTML error page instead of JSON. This usually indicates a server error or incorrect endpoint. Check server logs.`);
            }
            
            throw new Error(`Expected JSON but got ${contentType}. Response: ${text.substring(0, 200)}...`);
        }

        const data = await response.json();
        console.log(`[API] Success for ${url}:`, data);
        return data;

    } catch (error) {
        console.error(`[API] Failed for ${url}:`, error);
        
        // Enhanced error messages for common issues
        if (error.message.includes('Failed to fetch')) {
            error.message = `Network error: Could not connect to server. Check if the server is running on the correct port.`;
        } else if (error.message.includes('HTML error page')) {
            error.message = `Server error: The monitor API endpoint returned an error page. Check server logs for details.`;
        }
        
        throw error;
    } finally {
        apiCallsInProgress.delete(requestId);
    }
}

// Enhanced error display function
function showApiError(endpoint, error, containerId = null) {
    const errorHtml = `
        <div class="error-message">
            <strong>‚ùå API Error (${endpoint}):</strong><br>
            ${error.message}<br>
            <small>
                <strong>Troubleshooting:</strong><br>
                ‚Ä¢ Check if the Flask server is running<br>
                ‚Ä¢ Verify the monitor endpoints are configured<br>
                ‚Ä¢ Check server console for error details<br>
                ‚Ä¢ Try refreshing the page<br>
            </small>
            <button class="retry-button" onclick="retryApiCall('${endpoint}', '${containerId}')">
                üîÑ Retry
            </button>
        </div>
    `;
    
    if (containerId) {
        const container = document.getElementById(containerId);
        if (container) {
            container.innerHTML = errorHtml;
        }
    }
    
    log(`‚ùå API Error (${endpoint}): ${error.message}`, 'error');
}

// Retry function for failed API calls
function retryApiCall(endpoint, containerId) {
    log(`üîÑ Retrying API call to ${endpoint}...`, 'info');
    
    switch (endpoint) {
        case '/api/monitor/status':
            loadStatus();
            break;
        case '/api/monitor/alerts':
            loadAlerts();
            break;
        case '/api/monitor/config':
            // Reload would be handled by loadStatus()
            loadStatus();
            break;
        default:
            log(`‚ö†Ô∏è Don't know how to retry ${endpoint}`, 'warning');
    }
}

// Enhanced logging with different types and formatting
function log(message, type = 'info', showTimestamp = true) {
    console.log(`[Monitor] ${message}`);
    
    if (consolePaused) {
        consoleBuffer.push({message, type, showTimestamp, timestamp: new Date()});
        return;
    }
    
    const output = document.getElementById('console-output');
    const line = document.createElement('div');
    line.className = `console-line ${type}`;
    
    let formattedMessage = message;
    if (showTimestamp) {
        const timestamp = new Date().toLocaleTimeString();
        formattedMessage = `[${timestamp}] ${message}`;
    }
    
    // Handle special formatting for monitor output
    if (message.includes('='.repeat(60))) {
        line.className = 'console-line banner';
        formattedMessage = message;
    } else if (message.includes('üöÄ') || message.includes('üîç') || message.includes('üìä')) {
        line.className = 'console-line highlight';
    } else if (message.includes('Progress:') || message.includes('[')) {
        line.className = 'console-line progress';
    }
    
    line.textContent = formattedMessage;
    output.appendChild(line);
    
    // Auto-scroll if enabled
    if (autoScroll) {
        output.scrollTop = output.scrollHeight;
    }
    
    // Keep only last 1000 lines for performance
    const lines = output.children;
    if (lines.length > 1000) {
        for (let i = 0; i < 100; i++) {
            output.removeChild(lines[0]);
        }
    }
}

function logBanner(message) {
    log('='.repeat(70), 'banner', false);
    log(message, 'banner', false);
    log('='.repeat(70), 'banner', false);
}

function logProgress(current, total, message) {
    log(`üîÑ [${current}/${total}] ${message}`, 'progress');
}

function logAlert(message) {
    log(`üö® ALERT: ${message}`, 'highlight');
}

function clearConsole() {
    document.getElementById('console-output').innerHTML = '';
    log('üöÄ Monitor console ready. Click "Check Now" or "Start Monitor" to begin.');
    log('üí° Tip: Console will show detailed progress when analysis runs');
}

function toggleAutoScroll() {
    autoScroll = !autoScroll;
    const toggleText = document.getElementById('scroll-toggle-text');
    toggleText.textContent = `Auto Scroll: ${autoScroll ? 'ON' : 'OFF'}`;
    
    const output = document.getElementById('console-output');
    if (autoScroll) {
        output.classList.add('auto-scroll');
        output.scrollTop = output.scrollHeight;
    } else {
        output.classList.remove('auto-scroll');
    }
}

function pauseConsole() {
    consolePaused = !consolePaused;
    const pauseIcon = document.getElementById('pause-icon');
    const pauseText = document.getElementById('pause-text');
    
    if (consolePaused) {
        pauseIcon.className = 'fas fa-play';
        pauseText.textContent = 'Resume';
        log('‚è∏Ô∏è Console output paused', 'warning');
    } else {
        pauseIcon.className = 'fas fa-pause';
        pauseText.textContent = 'Pause';
        log('‚ñ∂Ô∏è Console output resumed', 'success');
        
        // Flush buffer
        while (consoleBuffer.length > 0) {
            const buffered = consoleBuffer.shift();
            log(buffered.message, buffered.type, buffered.showTimestamp);
        }
    }
}

function exportConsoleLog() {
    const output = document.getElementById('console-output');
    const lines = Array.from(output.children).map(line => line.textContent).join('\n');
    
    const blob = new Blob([lines], { type: 'text/plain' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `monitor-log-${new Date().toISOString().split('T')[0]}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    window.URL.revokeObjectURL(url);
    
    log('üìÅ Console log exported successfully', 'success');
}

// Load monitor status on page load
window.addEventListener('DOMContentLoaded', function() {
    log('üåê Page loaded, initializing monitor interface...');
    
    // Show loading state
    showLoadingState();
    
    // Start loading data with better error handling
    initializeMonitorPage();
    
    // Start polling for real-time updates when monitor is running
    setInterval(pollMonitorOutput, 2000);
});

function showLoadingState() {
    const elements = {
        'status-text': 'Loading status...',
        'monitor-status': 'Loading...',
        'last-check': 'Loading...',
        'next-check': 'Loading...',
        'total-alerts': '...',
        'known-tokens': '...'
    };
    
    Object.entries(elements).forEach(([id, text]) => {
        const element = document.getElementById(id);
        if (element) {
            element.textContent = text;
        }
    });
}

async function initializeMonitorPage() {
    log('üîß Initializing monitor page...', 'info');
    
    try {
        // Test basic connectivity first
        await testBasicConnectivity();
        
        // Load all components
        await Promise.allSettled([
            loadStatus(),
            loadAlerts()
        ]);
        
        log('‚úÖ Monitor page initialized successfully', 'success');
        
    } catch (error) {
        log(`‚ùå Failed to initialize monitor page: ${error.message}`, 'error');
        showApiError('initialization', error);
    }
}

async function testBasicConnectivity() {
    log('üîå Testing basic server connectivity...', 'info');
    
    try {
        // Test the simplest endpoint first
        const response = await fetch('/api/status');
        
        if (!response.ok) {
            throw new Error(`Server responded with ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        log('‚úÖ Server connectivity test passed', 'success');
        
        return data;
        
    } catch (error) {
        log(`‚ùå Server connectivity test failed: ${error.message}`, 'error');
        throw new Error(`Cannot connect to server: ${error.message}`);
    }
}

function pollMonitorOutput() {
    if (isMonitorRunning) {
        // This would connect to a real-time endpoint if available
        // For now, we'll just refresh status periodically
        loadStatus();
    }
}

async function loadStatus() {
    try {
        log('üì° Loading monitor status...', 'info');
        const data = await makeApiCall('/api/monitor/status');
        
        updateUI(data);
        
        // Show stats
        if (data.data && data.data.stats) {
            document.getElementById('total-alerts').textContent = data.data.stats.total_alerts || 0;
            document.getElementById('known-tokens').textContent = data.data.stats.known_tokens || 0;
        } else if (data.stats) {
            document.getElementById('total-alerts').textContent = data.stats.total_alerts || 0;
            document.getElementById('known-tokens').textContent = data.stats.known_tokens || 0;
        }
        
        log('‚úÖ Monitor status loaded successfully', 'success');
        
    } catch (error) {
        showApiError('/api/monitor/status', error);
        
        // Set default values when API fails
        document.getElementById('status-text').textContent = 'Status unavailable';
        document.getElementById('monitor-status').textContent = 'Unknown';
        document.getElementById('monitor-status').className = 'badge bg-danger';
    }
}

function updateUI(response) {
    // Handle both direct data and wrapped responses
    const status = response.data || response;
    
    const indicator = document.getElementById('status-indicator');
    const statusText = document.getElementById('status-text');
    const startBtn = document.getElementById('start-btn');
    const stopBtn = document.getElementById('stop-btn');
    const monitorStatus = document.getElementById('monitor-status');
    const consoleStatus = document.getElementById('console-status');
    
    isMonitorRunning = status.is_running;
    
    if (isMonitorRunning) {
        indicator.classList.add('active');
        statusText.textContent = 'Monitor Active';
        monitorStatus.className = 'badge bg-success';
        monitorStatus.textContent = 'Active';
        consoleStatus.style.display = 'inline-block';
        startBtn.style.display = 'none';
        stopBtn.style.display = 'inline-block';
        
        log('‚úÖ Monitor is running', 'success');
    } else {
        indicator.classList.remove('active');
        statusText.textContent = 'Monitor Inactive';
        monitorStatus.className = 'badge bg-secondary';
        monitorStatus.textContent = 'Inactive';
        consoleStatus.style.display = 'none';
        startBtn.style.display = 'inline-block';
        stopBtn.style.display = 'none';
    }
    
    if (status.last_check) {
        const lastCheck = new Date(status.last_check);
        document.getElementById('last-check').textContent = lastCheck.toLocaleTimeString();
    }
    
    if (status.next_check && isMonitorRunning) {
        const nextCheck = new Date(status.next_check);
        document.getElementById('next-check').textContent = nextCheck.toLocaleTimeString();
        
        // Calculate time until next check
        const now = new Date();
        const timeUntil = nextCheck - now;
        if (timeUntil > 0) {
            const minutes = Math.floor(timeUntil / 60000);
            const seconds = Math.floor((timeUntil % 60000) / 1000);
            log(`‚è∞ Next check in ${minutes}m ${seconds}s`, 'info');
        }
    } else {
        document.getElementById('next-check').textContent = '-';
    }
    
    // Update config fields
    if (status.config) {
        document.getElementById('interval-select').value = status.config.check_interval_minutes || 60;
        document.getElementById('num-wallets').value = status.config.num_wallets || 50;
        document.getElementById('use-interval-timeframe').checked = status.config.use_interval_for_timeframe !== false;
        
        // Update network checkboxes
        if (status.config.networks) {
            document.getElementById('network-eth').checked = status.config.networks.includes('ethereum');
            document.getElementById('network-base').checked = status.config.networks.includes('base');
        }
    }
    
    // Update thresholds
    if (status.alert_thresholds) {
        document.getElementById('min-wallets').value = status.alert_thresholds.min_wallets || 2;
        document.getElementById('min-eth').value = status.alert_thresholds.min_eth_total || 0.5;
        document.getElementById('min-score').value = status.alert_thresholds.min_alpha_score || 30;
    }
}

async function startMonitor() {
    logBanner('üöÄ STARTING CRYPTO MONITOR');
    log('üì° Sending start request to server...', 'info');
    
    try {
        const data = await makeApiCall('/api/monitor/start', { method: 'POST' });
        
        if (data.status === 'success') {
            log('‚úÖ Monitor started successfully!', 'success');
            log('üîÑ Monitor will now check for new tokens automatically', 'info');
            log(`‚è∞ Check interval: ${data.config ? data.config.check_interval_minutes : 'Unknown'} minutes`, 'info');
        } else {
            log(`‚ùå Failed to start monitor: ${data.message}`, 'error');
        }
        loadStatus();
    } catch (error) {
        log(`‚ùå Error starting monitor: ${error.message}`, 'error');
    }
}

async function stopMonitor() {
    logBanner('üõë STOPPING CRYPTO MONITOR');
    log('üì° Sending stop request to server...', 'info');
    
    try {
        const data = await makeApiCall('/api/monitor/stop', { method: 'POST' });
        
        if (data.status === 'success') {
            log('‚úÖ Monitor stopped successfully', 'success');
        } else {
            log(`‚ùå Failed to stop monitor: ${data.message}`, 'error');
        }
        loadStatus();
    } catch (error) {
        log(`‚ùå Error stopping monitor: ${error.message}`, 'error');
    }
}

async function checkNow() {
    logBanner('üîç IMMEDIATE CHECK INITIATED');
    log('üöÄ Starting immediate token analysis...', 'warning');
    log('üìä This will analyze recent wallet activity for new tokens', 'info');
    log('‚è≥ Please wait... Check will run in background', 'info');
    log('üí° Detailed progress will appear in server console', 'info');
    
    try {
        const data = await makeApiCall('/api/monitor/check-now', { method: 'POST' });
        
        if (data.status === 'success') {
            log('‚úÖ Immediate check initiated successfully!', 'success');
            log('üîç Analysis running... Results will appear shortly', 'info');
            
            // Simulate progress updates (since we don't have real-time SSE here)
            setTimeout(() => log('üìä Analyzing wallet transactions...', 'progress'), 2000);
            setTimeout(() => log('üîç Checking for new token activity...', 'progress'), 5000);
            setTimeout(() => log('üìà Calculating alpha scores...', 'progress'), 8000);
            setTimeout(() => {
                log('‚úÖ Analysis complete! Loading results...', 'success');
                loadAlerts();
                loadStatus();
            }, 12000);
        } else {
            log(`‚ùå Check failed: ${data.message}`, 'error');
        }
    } catch (error) {
        log(`‚ùå Error running immediate check: ${error.message}`, 'error');
    }
}

async function testConnection() {
    log('üîå Testing monitor connections...', 'info');
    log('üì° Checking API endpoints and database connectivity', 'info');
    
    try {
        const data = await makeApiCall('/api/monitor/test');
        
        if (data.status === 'success') {
            log('‚úÖ Connection test passed!', 'success');
            log(`üìä Test results: ${JSON.stringify(data.results)}`, 'info');
            
            // Display individual test results
            if (data.results) {
                Object.entries(data.results).forEach(([test, result]) => {
                    const status = result ? '‚úÖ' : '‚ùå';
                    log(`  ${status} ${test}: ${result ? 'OK' : 'FAILED'}`, result ? 'success' : 'error');
                });
            }
        } else {
            log(`‚ùå Connection test failed: ${data.message}`, 'error');
        }
    } catch (error) {
        log(`‚ùå Connection test error: ${error.message}`, 'error');
    }
}

async function updateConfig() {
    const networks = [];
    if (document.getElementById('network-eth').checked) networks.push('ethereum');
    if (document.getElementById('network-base').checked) networks.push('base');
    
    const config = {
        check_interval_minutes: parseInt(document.getElementById('interval-select').value),
        networks: networks,
        num_wallets: parseInt(document.getElementById('num-wallets').value),
        use_interval_for_timeframe: document.getElementById('use-interval-timeframe').checked
    };
    
    log(`‚öôÔ∏è Updating configuration...`, 'info');
    log(`üìä New settings: ${networks.join(', ')} networks, ${config.num_wallets} wallets, ${config.check_interval_minutes}min interval`, 'info');
    
    try {
        const data = await makeApiCall('/api/monitor/config', {
            method: 'POST',
            body: JSON.stringify(config)
        });
        
        if (data.status === 'success') {
            log('‚úÖ Configuration updated successfully', 'success');
            loadStatus();
        } else {
            log(`‚ùå Config update failed: ${data.message}`, 'error');
        }
    } catch (error) {
        log(`‚ùå Error updating config: ${error.message}`, 'error');
    }
}

async function updateThresholds() {
    const thresholds = {
        min_wallets: parseInt(document.getElementById('min-wallets').value),
        min_eth_total: parseFloat(document.getElementById('min-eth').value),
        min_alpha_score: parseFloat(document.getElementById('min-score').value)
    };
    
    log(`üéØ Updating alert thresholds...`, 'info');
    log(`üìä New thresholds: ${thresholds.min_wallets} wallets, ${thresholds.min_eth_total} ETH, Œ±‚â•${thresholds.min_alpha_score}`, 'info');
    
    try {
        const data = await makeApiCall('/api/monitor/thresholds', {
            method: 'POST',
            body: JSON.stringify(thresholds)
        });
        
        if (data.status === 'success') {
            log('‚úÖ Alert thresholds updated successfully', 'success');
        } else {
            log(`‚ùå Threshold update failed: ${data.message}`, 'error');
        }
    } catch (error) {
        log(`‚ùå Error updating thresholds: ${error.message}`, 'error');
    }
}

async function loadAlerts() {
    try {
        log('üìã Loading recent alerts...', 'info');
        const alerts = await makeApiCall('/api/monitor/alerts?limit=20');
        
        const container = document.getElementById('alerts-container');
        
        if (!alerts || alerts.length === 0) {
            container.innerHTML = '<p class="text-muted">No alerts yet. Start monitoring or run an immediate check to generate alerts.</p>';
        } else {
            log(`üìã Loading ${alerts.length} recent alerts`, 'info');
            
            let html = '';
            alerts.reverse().forEach(alert => {  // Show newest first
                const alertClass = getAlertClass(alert);
                const alertEmoji = getAlertEmoji(alert);
                const confidenceBadge = getConfidenceBadge(alert);
                const networkBadge = alert.network ? `<span class="badge bg-info ms-2">${alert.network.toUpperCase()}</span>` : '';
                
                html += `
                    <div class="alert-item ${alertClass}">
                        <div class="alert-token">
                            ${alertEmoji} ${alert.token} ${networkBadge} ${confidenceBadge}
                        </div>
                        <div class="row g-2 mb-2">
                            <div class="col-md-3">
                                <small class="text-muted">ETH Spent:</small>
                                <div class="fw-bold text-success">${(alert.data?.total_eth_spent || 0).toFixed(3)} ETH</div>
                            </div>
                            <div class="col-md-3">
                                <small class="text-muted">Wallets:</small>
                                <div class="fw-bold text-info">${alert.data?.wallet_count || 0}</div>
                            </div>
                            <div class="col-md-3">
                                <small class="text-muted">Score:</small>
                                <div class="fw-bold text-warning">${(alert.data?.alpha_score || alert.data?.sell_score || 0).toFixed(0)}</div>
                            </div>
                            <div class="col-md-3">
                                <small class="text-muted">Activity:</small>
                                <div class="small">${alert.data?.total_purchases || alert.data?.total_sells || 0} transactions</div>
                            </div>
                        </div>
                        <div class="row g-2 mb-2">
                            <div class="col-md-6">
                                <small class="text-muted">Platforms/Methods:</small>
                                <div class="small">${(alert.data?.platforms || alert.data?.methods || []).slice(0, 3).join(', ') || 'Unknown'}</div>
                            </div>
                            <div class="col-md-6">
                                <small class="text-muted">Alert Type:</small>
                                <div class="small text-capitalize">${alert.alert_type?.replace('_', ' ') || 'Unknown'}</div>
                            </div>
                        </div>
                        <div class="mt-2">
                            <small class="text-muted">
                                üïê ${new Date(alert.timestamp).toLocaleString()}
                            </small>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        log('‚úÖ Alerts loaded successfully', 'success');
        
    } catch (error) {
        showApiError('/api/monitor/alerts', error, 'alerts-container');
    }
}

function getAlertClass(alert) {
    if (alert.confidence === 'HIGH') return 'high-confidence';
    if (alert.confidence === 'MEDIUM') return 'medium-confidence';
    if (alert.alert_type === 'sell_pressure') return 'sell-pressure';
    return '';
}

function getAlertEmoji(alert) {
    switch (alert.alert_type) {
        case 'new_token': return 'üÜï';
        case 'high_activity': return 'üìà';
        case 'sell_pressure': return 'üìâ';
        default: return 'üîî';
    }
}

function getConfidenceBadge(alert) {
    const confidence = alert.confidence || 'LOW';
    const colors = {
        'HIGH': 'bg-danger',
        'MEDIUM': 'bg-warning',
        'LOW': 'bg-secondary'
    };
    const emojis = {
        'HIGH': 'üî•',
        'MEDIUM': '‚ö†Ô∏è',
        'LOW': '‚ÑπÔ∏è'
    };
    
    return `<span class="badge ${colors[confidence]} ms-2">${emojis[confidence]} ${confidence}</span>`;
}

// Auto-refresh status every 30 seconds when monitor is running
setInterval(() => {
    if (isMonitorRunning) {
        loadStatus();
        
        // Add a subtle progress indicator
        log('üîÑ Checking monitor status...', 'info');
    }
}, 30000);

// Countdown timer for next check
let countdownInterval;

function startCountdown(nextCheckTime) {
    if (countdownInterval) {
        clearInterval(countdownInterval);
    }
    
    countdownInterval = setInterval(() => {
        if (!isMonitorRunning) {
            clearInterval(countdownInterval);
            return;
        }
        
        const now = new Date();
        const nextCheck = new Date(nextCheckTime);
        const timeUntil = nextCheck - now;
        
        if (timeUntil <= 0) {
            log('‚è∞ Check time reached! Monitor should be analyzing now...', 'highlight');
            clearInterval(countdownInterval);
            return;
        }
        
        const minutes = Math.floor(timeUntil / 60000);
        const seconds = Math.floor((timeUntil % 60000) / 1000);
        
        // Update next check display with countdown
        document.getElementById('next-check').textContent = `${minutes}m ${seconds}s`;
        
        // Log countdown at specific intervals
        if (minutes === 1 && seconds === 0) {
            log('‚è∞ Next check in 1 minute', 'warning');
        } else if (minutes === 0 && seconds === 30) {
            log('‚è∞ Next check in 30 seconds', 'warning');
        } else if (minutes === 0 && seconds <= 10 && seconds > 0) {
            log(`‚è∞ Next check in ${seconds} seconds`, 'highlight');
        }
    }, 1000);
}

// Enhanced status updates with more detailed logging
async function enhancedStatusUpdate() {
    try {
        const data = await makeApiCall('/api/monitor/status');
        updateUI(data);
        
        // Start countdown if monitor is running and we have next check time
        const status = data.data || data;
        if (status.is_running && status.next_check) {
            startCountdown(status.next_check);
        }
        
        // Log interesting changes
        if (status.stats && status.stats.total_alerts > 0) {
            const newAlerts = status.stats.total_alerts - (window.lastAlertCount || 0);
            if (newAlerts > 0) {
                logAlert(`${newAlerts} new alert(s) detected!`);
                window.lastAlertCount = status.stats.total_alerts;
            }
        }
    } catch (error) {
        if (error.message.includes('fetch')) {
            log('‚ö†Ô∏è Connection to monitor lost, retrying...', 'warning');
        }
    }
}

// Replace the simple setInterval with enhanced updates
setInterval(enhancedStatusUpdate, 10000); // Every 10 seconds for more responsive updates

// Page visibility API to pause updates when tab is not active
document.addEventListener('visibilitychange', function() {
    if (document.hidden) {
        log('üëÅÔ∏è Tab hidden, reducing update frequency', 'info');
    } else {
        log('üëÅÔ∏è Tab visible, resuming normal updates', 'info');
        loadStatus(); // Immediate update when tab becomes visible
    }
});

// Keyboard shortcuts
document.addEventListener('keydown', function(e) {
    // Ctrl/Cmd + Enter to run immediate check
    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
        e.preventDefault();
        checkNow();
        log('‚å®Ô∏è Keyboard shortcut: Immediate check triggered', 'info');
    }
    
    // Ctrl/Cmd + Shift + C to clear console
    if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'C') {
        e.preventDefault();
        clearConsole();
        log('‚å®Ô∏è Keyboard shortcut: Console cleared', 'info');
    }
});

// Welcome message with tips
setTimeout(() => {
    if (document.getElementById('console-output').children.length <= 2) {
        log('üí° Pro Tips:', 'info');
        log('  ‚Ä¢ Ctrl+Enter: Run immediate check', 'info');
        log('  ‚Ä¢ Ctrl+Shift+C: Clear console', 'info');
        log('  ‚Ä¢ Auto-scroll can be toggled with the button above', 'info');
        log('  ‚Ä¢ Console output can be paused and exported', 'info');
    }
}, 3000);

// Add a diagnostic function for debugging
window.debugMonitorPage = function() {
    console.log('=== Monitor Page Debug Info ===');
    console.log('API calls in progress:', apiCallsInProgress.size);
    console.log('Monitor running:', isMonitorRunning);
    console.log('Auto scroll:', autoScroll);
    console.log('Console paused:', consolePaused);
    console.log('Buffer size:', consoleBuffer.length);
    
    // Test all monitor endpoints
    const endpoints = [
        '/api/monitor/status',
        '/api/monitor/config',
        '/api/monitor/alerts',
        '/api/monitor/test'
    ];
    
    console.log('Testing monitor endpoints...');
    endpoints.forEach(async (endpoint) => {
        try {
            const response = await fetch(endpoint);
            console.log(`${endpoint}: ${response.status} ${response.statusText}`);
            if (!response.ok) {
                const text = await response.text();
                console.log(`  Error response:`, text.substring(0, 200));
            }
        } catch (error) {
            console.error(`${endpoint}: ERROR -`, error.message);
        }
    });
};

// Expose debug function to console
console.log('üí° Debug function available: debugMonitorPage()');
</script>
{% endblock %}